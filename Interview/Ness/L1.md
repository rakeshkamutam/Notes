# Ness | FS - Interview Questions & Answers

## Table of Contents
1. [Give me 5 ways of component communication in Angular?](#1-give-me-5-ways-of-component-communication-in-angular)
2. [What is Subject and Behavioral Subject? Why we need](#2-what-is-subject-and-behavioral-subject-why-we-need)
3. [How do you handle errors Globally?](#3-how-do-you-handle-errors-globally)
4. [Where do you store the JWT token in Angular?](#4-where-do-you-store-the-jwt-token-in-angular)
5. [How do you pass/get the token in Angular](#5-how-do-you-passget-the-token-in-angular)
6. [Which Angular version are you currently using in your project?](#6-which-angular-version-are-you-currently-using-in-your-project)
7. [What do you know about NgRx in Angular?](#7-what-do-you-know-about-ngrx-in-angular)
8. [What are Angular Interceptors?](#8-what-are-angular-interceptors)
9. [Write a SQL Query to get result in columns as rows and vice-versa](#9-write-a-sql-query-to-get-result-in-columns-as-rows-and-vice-versa)
10. [What is Angular Guards and their types?](#10-what-is-angular-guards-and-their-types)
11. [Performance improvement for microservices database operations](#11-performance-improvement-for-microservices-database-operations)
12. [How do you implement JWT in .NET Core Web API](#12-how-do-you-implement-jwt-in-net-core-web-api)
13. [What is cache? How do implement it? What are different types](#13-what-is-cache-how-do-implement-it-what-are-different-types)
14. [Can we create an object in class for a constructor? Are you sure](#14-can-we-create-an-object-in-class-for-a-constructor-are-you-sure)

***

## 1. Give me 5 ways of component communication in Angular?

Angular provides multiple ways for components to communicate with each other:[1][2]

### **1. Parent to Child Communication (@Input)**
```typescript
// Parent Component
@Component({
  template: ``
})
export class ParentComponent {
  parentData = 'Hello from parent';
}

// Child Component
@Component({
  selector: 'child-component',
  template: `{{data}}`
})
export class ChildComponent {
  @Input() data: string;
}
```

### **2. Child to Parent Communication (@Output & EventEmitter)**
```typescript
// Child Component
@Component({
  selector: 'child-component',
  template: `Send Data`
})
export class ChildComponent {
  @Output() dataEvent = new EventEmitter();
  
  sendData() {
    this.dataEvent.emit('Data from child');
  }
}

// Parent Component
@Component({
  template: ``
})
export class ParentComponent {
  receiveData(data: string) {
    console.log(data);
  }
}
```

### **3. Service with Observables**
```typescript
@Injectable({
  providedIn: 'root'
})
export class DataService {
  private messageSubject = new BehaviorSubject('');
  message$ = this.messageSubject.asObservable();
  
  sendMessage(message: string) {
    this.messageSubject.next(message);
  }
}

// Component usage
export class ComponentA {
  constructor(private dataService: DataService) {}
  
  sendMessage() {
    this.dataService.sendMessage('Hello from Component A');
  }
}

export class ComponentB implements OnInit {
  message: string;
  
  constructor(private dataService: DataService) {}
  
  ngOnInit() {
    this.dataService.message$.subscribe(msg => this.message = msg);
  }
}
```

### **4. ViewChild/ViewChildren**
```typescript
// Parent Component
@Component({
  template: `
    
    Call Child Method
  `
})
export class ParentComponent {
  @ViewChild('childRef') childComponent: ChildComponent;
  
  callChildMethod() {
    this.childComponent.childMethod();
  }
}

// Child Component
export class ChildComponent {
  childMethod() {
    console.log('Method called from parent');
  }
}
```

### **5. Template Reference Variables**
```typescript
@Component({
  template: `
    
    Direct Call
  `
})
export class ParentComponent {}
```

[ðŸ”¼ Back to Top](#table-of-contents)

***

## 2. What is Subject and Behavioral Subject? Why we need

**Subject** and **BehaviorSubject** are both RxJS observables that allow multicasting to multiple observers.[3][4]

### **Subject**
- **No initial value** - Doesn't store any value
- **Only emits new values** to subscribers after subscription
- **Hot observable** - Emits regardless of subscribers

```typescript
import { Subject } from 'rxjs';

// Subject Example
const subject = new Subject();

// Subscribe before emission
subject.subscribe(value => console.log('Subscriber 1:', value));

subject.next('First message'); // Only Subscriber 1 receives this

// Subscribe after emission
subject.subscribe(value => console.log('Subscriber 2:', value));

subject.next('Second message'); // Both subscribers receive this
```

### **BehaviorSubject**
- **Requires initial value** - Always has a current value
- **Emits current value** to new subscribers immediately
- **Stores the last emitted value**

```typescript
import { BehaviorSubject } from 'rxjs';

// BehaviorSubject Example
const behaviorSubject = new BehaviorSubject('Initial Value');

// Subscribe - immediately gets current value
behaviorSubject.subscribe(value => console.log('Subscriber 1:', value)); 
// Output: "Initial Value"

behaviorSubject.next('First update');

// New subscriber gets the latest value immediately
behaviorSubject.subscribe(value => console.log('Subscriber 2:', value)); 
// Output: "First update"
```

### **Key Differences**

| Feature | Subject | BehaviorSubject |
|---------|---------|-----------------|
| **Initial Value** | No | Required |
| **Current Value** | None | Always available |
| **Late Subscribers** | Get only new values | Get current value immediately |
| **Use Case** | Events, notifications | State management |

### **Why We Need Them**

**Subject Use Cases:**
- Event handling
- One-time notifications
- Simple communication between components

**BehaviorSubject Use Cases:**
- State management
- User authentication status
- Configuration settings
- Any scenario where late subscribers need current state

```typescript
// Real-world example: Authentication Service
@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private isAuthenticatedSubject = new BehaviorSubject(false);
  isAuthenticated$ = this.isAuthenticatedSubject.asObservable();
  
  login(credentials: any) {
    // Perform login logic
    this.isAuthenticatedSubject.next(true);
  }
  
  logout() {
    this.isAuthenticatedSubject.next(false);
  }
  
  // Any component subscribing later gets current auth status immediately
  getCurrentAuthStatus(): boolean {
    return this.isAuthenticatedSubject.value;
  }
}
```

[ðŸ”¼ Back to Top](#table-of-contents)

***

## 3. How do you handle errors Globally?

Global error handling in Angular is achieved by creating a custom **ErrorHandler** service that extends Angular's built-in **ErrorHandler** class.[5][6]

### **Creating Global Error Handler**

```typescript
import { ErrorHandler, Injectable, Injector } from '@angular/core';
import { HttpErrorResponse } from '@angular/common/http';

@Injectable()
export class GlobalErrorHandler implements ErrorHandler {
  
  constructor(private injector: Injector) {}
  
  handleError(error: any): void {
    console.error('Global error caught: ', error);
    
    if (error instanceof HttpErrorResponse) {
      // HTTP errors
      this.handleHttpError(error);
    } else {
      // Client-side errors
      this.handleClientError(error);
    }
  }
  
  private handleHttpError(error: HttpErrorResponse) {
    switch (error.status) {
      case 400:
        this.showErrorMessage('Bad Request');
        break;
      case 401:
        this.showErrorMessage('Unauthorized');
        this.redirectToLogin();
        break;
      case 403:
        this.showErrorMessage('Forbidden');
        break;
      case 404:
        this.showErrorMessage('Not Found');
        break;
      case 500:
        this.showErrorMessage('Internal Server Error');
        break;
      default:
        this.showErrorMessage('An unexpected error occurred');
    }
  }
  
  private handleClientError(error: Error) {
    this.showErrorMessage(`Client Error: ${error.message}`);
    // Log to external service
    this.logErrorToService(error);
  }
  
  private showErrorMessage(message: string) {
    // Show user-friendly error message
    // You can inject a notification service here
    alert(message); // Replace with proper notification
  }
  
  private redirectToLogin() {
    // Inject Router and navigate to login
    // const router = this.injector.get(Router);
    // router.navigate(['/login']);
  }
  
  private logErrorToService(error: any) {
    // Log to external monitoring service like Sentry, LogRocket, etc.
    console.log('Logging error to external service:', error);
  }
}
```

### **Registering Global Error Handler**

```typescript
// app.config.ts (Angular 17+)
import { ApplicationConfig } from '@angular/core';
import { provideRouter } from '@angular/router';
import { ErrorHandler } from '@angular/core';
import { GlobalErrorHandler } from './global-error-handler';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes),
    { provide: ErrorHandler, useClass: GlobalErrorHandler }
  ]
};

// OR in app.module.ts (older versions)
@NgModule({
  providers: [
    { provide: ErrorHandler, useClass: GlobalErrorHandler }
  ]
})
export class AppModule { }
```

### **HTTP Error Interceptor**

```typescript
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpErrorResponse } from '@angular/common/http';
import { catchError } from 'rxjs/operators';
import { throwError } from 'rxjs';

@Injectable()
export class HttpErrorInterceptor implements HttpInterceptor {
  
  intercept(req: HttpRequest, next: HttpHandler) {
    return next.handle(req).pipe(
      catchError((error: HttpErrorResponse) => {
        let errorMessage = '';
        
        if (error.error instanceof ErrorEvent) {
          // Client-side error
          errorMessage = `Error: ${error.error.message}`;
        } else {
          // Server-side error
          errorMessage = `Error Code: ${error.status}\nMessage: ${error.message}`;
        }
        
        console.error(errorMessage);
        return throwError(() => error);
      })
    );
  }
}

// Register interceptor
providers: [
  {
    provide: HTTP_INTERCEPTORS,
    useClass: HttpErrorInterceptor,
    multi: true
  }
]
```

### **Usage Example**

```typescript
@Component({
  template: `
    Trigger Error
    Make HTTP Call
  `
})
export class TestComponent {
  data: any;
  
  constructor(private http: HttpClient) {}
  
  triggerError() {
    // This will be caught by global error handler
    throw new Error('Test client error');
  }
  
  makeHttpCall() {
    this.http.get('/api/nonexistent').subscribe({
      next: (data) => this.data = data,
      // Error will be caught by HTTP interceptor and global handler
    });
  }
}
```

[ðŸ”¼ Back to Top](#table-of-contents)

***

## 4. Where do you store the JWT token in Angular?

The secure storage of JWT tokens is crucial for application security. Here are the recommended approaches:[7][8]

### **Recommended: In-Memory Storage (Most Secure)**

```typescript
@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private token: string | null = null;
  
  setToken(token: string): void {
    this.token = token;
  }
  
  getToken(): string | null {
    return this.token;
  }
  
  clearToken(): void {
    this.token = null;
  }
  
  isAuthenticated(): boolean {
    return !!this.token;
  }
}
```

**Pros:**
- Most secure - not accessible via XSS attacks
- Automatically cleared when user closes browser

**Cons:**
- Lost on page refresh
- Requires additional mechanism for persistence

### **Secure Cookies (HttpOnly)**

```typescript
// This must be set from the server-side
// Cookie: token=jwt_value; HttpOnly; Secure; SameSite=Strict

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  // Token is automatically sent with HTTP requests
  // No need to manually handle in Angular
  
  logout() {
    // Call server endpoint to clear cookie
    return this.http.post('/api/logout', {});
  }
}
```

**Pros:**
- Secure from XSS attacks (HttpOnly)
- Automatically included in requests
- Can be configured for HTTPS only

**Cons:**
- Vulnerable to CSRF attacks (mitigated by SameSite)
- Requires server-side implementation

### **Session Storage (Less Secure)**

```typescript
@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private readonly TOKEN_KEY = 'jwt_token';
  
  setToken(token: string): void {
    sessionStorage.setItem(this.TOKEN_KEY, token);
  }
  
  getToken(): string | null {
    return sessionStorage.getItem(this.TOKEN_KEY);
  }
  
  clearToken(): void {
    sessionStorage.removeItem(this.TOKEN_KEY);
  }
}
```

### **Local Storage (Not Recommended)**

```typescript
@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private readonly TOKEN_KEY = 'jwt_token';
  
  setToken(token: string): void {
    localStorage.setItem(this.TOKEN_KEY, token);
  }
  
  getToken(): string | null {
    return localStorage.getItem(this.TOKEN_KEY);
  }
  
  clearToken(): void {
    localStorage.removeItem(this.TOKEN_KEY);
  }
}
```

**Why Not Recommended:**
- Vulnerable to XSS attacks
- Persists even after browser closes
- Accessible by any script on the same domain

### **Hybrid Approach (In-Memory + Refresh Token)**

```typescript
@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private accessToken: string | null = null;
  private refreshToken: string | null = null;
  
  login(credentials: any) {
    return this.http.post('/api/login', credentials).pipe(
      tap(response => {
        this.accessToken = response.accessToken;
        // Store refresh token in httpOnly cookie (server-side)
        this.refreshToken = response.refreshToken;
      })
    );
  }
  
  getAccessToken(): string | null {
    return this.accessToken;
  }
  
  refreshAccessToken() {
    return this.http.post('/api/refresh', {}).pipe(
      tap(response => {
        this.accessToken = response.accessToken;
      })
    );
  }
}
```

**Security Recommendations:**
1. **Use HTTPS** always
2. **Implement token expiration** and refresh mechanism
3. **Use secure, httpOnly cookies** for refresh tokens
4. **Validate tokens** on the server-side
5. **Implement proper logout** that clears all tokens

[ðŸ”¼ Back to Top](#table-of-contents)

***

## 5. How do you pass/get the token in Angular

There are several ways to pass and retrieve JWT tokens in Angular applications:[9][10]

### **1. HTTP Interceptor (Recommended)**

```typescript
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler } from '@angular/common/http';
import { AuthService } from './auth.service';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  
  constructor(private authService: AuthService) {}
  
  intercept(req: HttpRequest, next: HttpHandler) {
    const token = this.authService.getToken();
    
    if (token) {
      const authReq = req.clone({
        headers: req.headers.set('Authorization', `Bearer ${token}`)
      });
      return next.handle(authReq);
    }
    
    return next.handle(req);
  }
}

// Register interceptor
providers: [
  {
    provide: HTTP_INTERCEPTORS,
    useClass: AuthInterceptor,
    multi: true
  }
]
```

### **2. Service with HTTP Headers**

```typescript
@Injectable({
  providedIn: 'root'
})
export class ApiService {
  
  constructor(
    private http: HttpClient,
    private authService: AuthService
  ) {}
  
  private getAuthHeaders(): HttpHeaders {
    const token = this.authService.getToken();
    return new HttpHeaders({
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    });
  }
  
  getData(url: string) {
    return this.http.get(url, {
      headers: this.getAuthHeaders()
    });
  }
  
  postData(url: string, data: any) {
    return this.http.post(url, data, {
      headers: this.getAuthHeaders()
    });
  }
}
```

### **3. Manual Header Setting**

```typescript
@Component({})
export class DataComponent {
  
  constructor(private http: HttpClient) {}
  
  fetchData() {
    const token = localStorage.getItem('token'); // or from service
    
    const headers = new HttpHeaders({
      'Authorization': `Bearer ${token}`
    });
    
    this.http.get('/api/data', { headers }).subscribe(
      data => console.log(data),
      error => console.error(error)
    );
  }
  
  // Alternative approach
  fetchDataAlternative() {
    const token = localStorage.getItem('token');
    
    this.http.get('/api/data', {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    }).subscribe(data => console.log(data));
  }
}
```

### **4. Using RxJS Operators**

```typescript
@Injectable({
  providedIn: 'root'
})
export class ApiService {
  
  constructor(
    private http: HttpClient,
    private authService: AuthService
  ) {}
  
  getData(url: string) {
    return this.authService.getToken().pipe(
      switchMap(token => {
        const headers = new HttpHeaders({
          'Authorization': `Bearer ${token}`
        });
        return this.http.get(url, { headers });
      })
    );
  }
}
```

### **5. Guards for Route Protection**

```typescript
@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {
  
  constructor(
    private authService: AuthService,
    private router: Router
  ) {}
  
  canActivate(): boolean {
    const token = this.authService.getToken();
    
    if (token && !this.isTokenExpired(token)) {
      return true;
    }
    
    this.router.navigate(['/login']);
    return false;
  }
  
  private isTokenExpired(token: string): boolean {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const currentTime = Math.floor(Date.now() / 1000);
      return payload.exp (null);
  public token$ = this.tokenSubject.asObservable();
  
  constructor(private http: HttpClient) {
    // Initialize token from storage
    const token = localStorage.getItem('token');
    if (token) {
      this.tokenSubject.next(token);
    }
  }
  
  login(credentials: any) {
    return this.http.post('/api/login', credentials).pipe(
      tap(response => {
        const token = response.token;
        localStorage.setItem('token', token);
        this.tokenSubject.next(token);
      })
    );
  }
  
  getToken(): string | null {
    return this.tokenSubject.value;
  }
  
  logout() {
    localStorage.removeItem('token');
    this.tokenSubject.next(null);
  }
  
  isAuthenticated(): boolean {
    const token = this.getToken();
    return !!token && !this.isTokenExpired(token);
  }
  
  private isTokenExpired(token: string): boolean {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      return payload.exp Count: {{ count() }}
    +
  `
})
export class CounterComponent {
  count = signal(0);
  
  increment() {
    this.count.update(value => value + 1);
  }
}

// New Control Flow Syntax
@Component({
  template: `
    @if (user) {
      Welcome, {{ user.name }}!
    } @else {
      Please log in
    }
    
    @for (item of items; track item.id) {
      {{ item.name }}
    }
  `
})
export class MyComponent {
  user = signal(null);
  items = signal([]);
}
```

### **Version Selection Strategy**

```typescript
// Check if you need LTS or latest
const versionStrategy = {
  "Enterprise/Production": "Angular 18 LTS", // Stable, long-term support
  "New Projects": "Angular 19/20", // Latest features
  "Learning/Experimentation": "Angular 20", // Cutting edge
  "Legacy Projects": "Gradual upgrade path" // Step-by-step migration
};
```

### **Migration Considerations**

```bash
# Update to latest version
ng update @angular/cli @angular/core

# Update specific packages
ng update @angular/material

# Check what can be updated
ng update

# Update with force (careful!)
ng update @angular/cli @angular/core --force
```

**Recommendation for 2025:**
- **New projects**: Use Angular 19+ for latest features
- **Production apps**: Consider Angular 18 LTS for stability
- **Enterprise**: Angular 18 LTS with planned migration strategy

[ðŸ”¼ Back to Top](#table-of-contents)

***

## 7. What do you know about NgRx in Angular?

**NgRx** is a reactive state management library for Angular applications, inspired by Redux pattern. It provides a predictable state container using RxJS observables.[13][14]

### **Core Concepts**

#### **Store**
- Single source of truth for application state
- Immutable state tree
- Centralized state management

#### **Actions**
- Describe what happened in the application
- Plain objects with type and optional payload

#### **Reducers**
- Pure functions that specify how state changes
- Take current state and action, return new state

#### **Effects**
- Handle side effects (HTTP calls, routing, etc.)
- Listen for actions and perform asynchronous operations

#### **Selectors**
- Functions to select slices of state
- Memoized for performance

### **Basic NgRx Implementation**

```typescript
// 1. Install NgRx
// npm install @ngrx/store @ngrx/effects @ngrx/store-devtools

// 2. Define State Interface
export interface AppState {
  articles: ArticleState;
}

export interface ArticleState {
  articles: Article[];
  loading: boolean;
  error: string | null;
}

// 3. Define Actions
export const loadArticles = createAction('[Article] Load Articles');
export const loadArticlesSuccess = createAction(
  '[Article] Load Articles Success',
  props()
);
export const loadArticlesFailure = createAction(
  '[Article] Load Articles Failure',
  props()
);

// 4. Create Reducer
const initialState: ArticleState = {
  articles: [],
  loading: false,
  error: null
};

export const articleReducer = createReducer(
  initialState,
  on(loadArticles, state => ({
    ...state,
    loading: true,
    error: null
  })),
  on(loadArticlesSuccess, (state, { articles }) => ({
    ...state,
    articles,
    loading: false
  })),
  on(loadArticlesFailure, (state, { error }) => ({
    ...state,
    loading: false,
    error
  }))
);

// 5. Create Effects
@Injectable()
export class ArticleEffects {
  
  loadArticles$ = createEffect(() =>
    this.actions$.pipe(
      ofType(loadArticles),
      switchMap(() =>
        this.articleService.getArticles().pipe(
          map(articles => loadArticlesSuccess({ articles })),
          catchError(error => of(loadArticlesFailure({ error: error.message })))
        )
      )
    )
  );
  
  constructor(
    private actions$: Actions,
    private articleService: ArticleService
  ) {}
}

// 6. Create Selectors
export const selectArticleState = (state: AppState) => state.articles;

export const selectAllArticles = createSelector(
  selectArticleState,
  state => state.articles
);

export const selectArticleLoading = createSelector(
  selectArticleState,
  state => state.loading
);

export const selectArticleError = createSelector(
  selectArticleState,
  state => state.error
);
```

### **Register NgRx in Application**

```typescript
// app.config.ts
import { ApplicationConfig } from '@angular/core';
import { provideStore } from '@ngrx/store';
import { provideEffects } from '@ngrx/effects';
import { provideStoreDevtools } from '@ngrx/store-devtools';

export const appConfig: ApplicationConfig = {
  providers: [
    provideStore({ articles: articleReducer }),
    provideEffects([ArticleEffects]),
    provideStoreDevtools({
      maxAge: 25, // Retains last 25 states
      logOnly: environment.production
    })
  ]
};
```

### **Component Usage**

```typescript
@Component({
  selector: 'app-article-list',
  template: `
    Loading...
    {{ error }}
    
    
      {{ article.title }}
      {{ article.content }}
    
    
    Load Articles
  `
})
export class ArticleListComponent implements OnInit {
  articles$ = this.store.select(selectAllArticles);
  loading$ = this.store.select(selectArticleLoading);
  error$ = this.store.select(selectArticleError);
  
  constructor(private store: Store) {}
  
  ngOnInit() {
    this.loadArticles();
  }
  
  loadArticles() {
    this.store.dispatch(loadArticles());
  }
}
```

### **Advanced NgRx Features**

#### **Entity State**
```typescript
import { EntityState, EntityAdapter, createEntityAdapter } from '@ngrx/entity';

export interface ArticleState extends EntityState {
  loading: boolean;
  error: string | null;
}

export const articleAdapter: EntityAdapter = createEntityAdapter();

const initialState: ArticleState = articleAdapter.getInitialState({
  loading: false,
  error: null
});

export const articleReducer = createReducer(
  initialState,
  on(loadArticlesSuccess, (state, { articles }) =>
    articleAdapter.setAll(articles, { ...state, loading: false })
  )
);

// Entity Selectors
const { selectIds, selectEntities, selectAll, selectTotal } = articleAdapter.getSelectors();

export const selectAllArticles = createSelector(selectArticleState, selectAll);
export const selectArticleEntities = createSelector(selectArticleState, selectEntities);
```

### **NgRx Benefits**
- **Predictable state management** - Unidirectional data flow
- **Time-travel debugging** - Redux DevTools support
- **Testability** - Pure functions and isolated side effects
- **Performance** - OnPush change detection strategy
- **Scalability** - Organized code structure for large apps

### **When to Use NgRx**
- Complex state management requirements
- Multiple components sharing state
- Need for debugging and time travel
- Large applications with many developers
- State persistence requirements

[ðŸ”¼ Back to Top](#table-of-contents)

***

## 8. What are Angular Interceptors?

**Angular Interceptors** are a powerful feature that allows you to intercept and modify HTTP requests and responses globally. They implement the `HttpInterceptor` interface.

### **Common Use Cases**
- Adding authentication headers
- Logging requests and responses
- Error handling
- Loading indicators
- Caching
- Request/response transformation

### **Basic Interceptor Implementation**

```typescript
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  
  intercept(req: HttpRequest, next: HttpHandler): Observable> {
    // Clone the request and add authorization header
    const authReq = req.clone({
      headers: req.headers.set('Authorization', 'Bearer token123')
    });
    
    // Pass the cloned request instead of the original request
    return next.handle(authReq);
  }
}
```

### **Advanced Interceptor Examples**

#### **1. Logging Interceptor**
```typescript
@Injectable()
export class LoggingInterceptor implements HttpInterceptor {
  
  intercept(req: HttpRequest, next: HttpHandler): Observable> {
    console.log('Outgoing request:', req.url);
    
    return next.handle(req).pipe(
      tap(event => {
        if (event instanceof HttpResponse) {
          console.log('Response received:', event.status);
        }
      })
    );
  }
}
```

#### **2. Error Handling Interceptor**
```typescript
@Injectable()
export class ErrorInterceptor implements HttpInterceptor {
  
  constructor(private notificationService: NotificationService) {}
  
  intercept(req: HttpRequest, next: HttpHandler): Observable> {
    return next.handle(req).pipe(
      catchError((error: HttpErrorResponse) => {
        let errorMessage = 'An error occurred';
        
        if (error.status === 401) {
          errorMessage = 'Unauthorized';
          // Redirect to login
        } else if (error.status === 500) {
          errorMessage = 'Internal server error';
        }
        
        this.notificationService.showError(errorMessage);
        return throwError(() => error);
      })
    );
  }
}
```

#### **3. Loading Interceptor**
```typescript
@Injectable()
export class LoadingInterceptor implements HttpInterceptor {
  
  constructor(private loadingService: LoadingService) {}
  
  intercept(req: HttpRequest, next: HttpHandler): Observable> {
    this.loadingService.setLoading(true);
    
    return next.handle(req).pipe(
      finalize(() => this.loadingService.setLoading(false))
    );
  }
}
```

#### **4. Cache Interceptor**
```typescript
@Injectable()
export class CacheInterceptor implements HttpInterceptor {
  private cache = new Map>();
  
  intercept(req: HttpRequest, next: HttpHandler): Observable> {
    // Only cache GET requests
    if (req.method !== 'GET') {
      return next.handle(req);
    }
    
    const cachedResponse = this.cache.get(req.url);
    if (cachedResponse) {
      return of(cachedResponse);
    }
    
    return next.handle(req).pipe(
      tap(event => {
        if (event instanceof HttpResponse) {
          this.cache.set(req.url, event);
        }
      })
    );
  }
}
```

### **Registering Interceptors**

```typescript
// app.config.ts (Angular 17+)
import { ApplicationConfig } from '@angular/core';
import { provideHttpClient, withInterceptors } from '@angular/common/http';

export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(
      withInterceptors([
        AuthInterceptor,
        LoggingInterceptor,
        ErrorInterceptor
      ])
    )
  ]
};

// Or using HTTP_INTERCEPTORS token (older approach)
providers: [
  {
    provide: HTTP_INTERCEPTORS,
    useClass: AuthInterceptor,
    multi: true
  },
  {
    provide: HTTP_INTERCEPTORS,
    useClass: LoggingInterceptor,
    multi: true
  }
]
```

### **Conditional Interceptor**

```typescript
@Injectable()
export class ConditionalInterceptor implements HttpInterceptor {
  
  intercept(req: HttpRequest, next: HttpHandler): Observable> {
    // Skip interceptor for specific URLs
    if (req.url.includes('/public/')) {
      return next.handle(req);
    }
    
    // Apply interceptor logic for other requests
    const modifiedReq = req.clone({
      setHeaders: {
        'Custom-Header': 'custom-value'
      }
    });
    
    return next.handle(modifiedReq);
  }
}
```

### **Multiple Header Modifications**

```typescript
@Injectable()
export class HeaderInterceptor implements HttpInterceptor {
  
  intercept(req: HttpRequest, next: HttpHandler): Observable> {
    const token = localStorage.getItem('token');
    
    const modifiedReq = req.clone({
      setHeaders: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest'
      }
    });
    
    return next.handle(modifiedReq);
  }
}
```

**Key Points:**
- Interceptors run in the order they are provided
- Always clone the request before modifying
- Use `next.handle()` to pass request to next interceptor
- Can modify both requests and responses
- Perfect for cross-cutting concerns

[ðŸ”¼ Back to Top](#table-of-contents)

***

## 9. Write a SQL Query to get result in columns as rows and vice-versa

SQL provides several ways to transpose data between rows and columns using techniques like PIVOT, UNPIVOT, and CASE statements.[15][16]

### **Transpose Rows to Columns (PIVOT)**

#### **Sample Data:**
```sql
-- Students table
StudentName | Subject | Score
------------|---------|------
John        | Math    | 85
John        | Science | 92
John        | English | 78
Jane        | Math    | 90
Jane        | Science | 88
Jane        | English | 95
```

#### **Method 1: Using CASE WHEN**
```sql
SELECT 
    StudentName,
    MAX(CASE WHEN Subject = 'Math' THEN Score END) AS Math,
    MAX(CASE WHEN Subject = 'Science' THEN Score END) AS Science,
    MAX(CASE WHEN Subject = 'English' THEN Score END) AS English
FROM Students
GROUP BY StudentName;

-- Result:
-- StudentName | Math | Science | English
-- ------------|------|---------|--------
-- John        | 85   | 92      | 78
-- Jane        | 90   | 88      | 95
```

#### **Method 2: Using PIVOT (SQL Server)**
```sql
SELECT StudentName, [Math], [Science], [English]
FROM (
    SELECT StudentName, Subject, Score
    FROM Students
) AS SourceTable
PIVOT (
    MAX(Score)
    FOR Subject IN ([Math], [Science], [English])
) AS PivotTable;
```

### **Transpose Columns to Rows (UNPIVOT)**

#### **Sample Data:**
```sql
-- StudentsScores table
StudentName | Math | Science | English
------------|------|---------|--------
John        | 85   | 92      | 78
Jane        | 90   | 88      | 95
```

#### **Method 1: Using UNION ALL**
```sql
SELECT StudentName, 'Math' AS Subject, Math AS Score
FROM StudentsScores
WHERE Math IS NOT NULL
UNION ALL
SELECT StudentName, 'Science' AS Subject, Science AS Score
FROM StudentsScores
WHERE Science IS NOT NULL
UNION ALL
SELECT StudentName, 'English' AS Subject, English AS Score
FROM StudentsScores
WHERE English IS NOT NULL
ORDER BY StudentName, Subject;

-- Result:
-- StudentName | Subject | Score
-- ------------|---------|------
-- Jane        | English | 95
-- Jane        | Math    | 90
-- Jane        | Science | 88
-- John        | English | 78
-- John        | Math    | 85
-- John        | Science | 92
```

#### **Method 2: Using UNPIVOT (SQL Server)**
```sql
SELECT StudentName, Subject, Score
FROM (
    SELECT StudentName, Math, Science, English
    FROM StudentsScores
) AS SourceTable
UNPIVOT (
    Score FOR Subject IN (Math, Science, English)
) AS UnpivotTable
ORDER BY StudentName, Subject;
```

### **Dynamic PIVOT (SQL Server)**

```sql
DECLARE @columns NVARCHAR(MAX), @sql NVARCHAR(MAX)

-- Get distinct subjects
SELECT @columns = COALESCE(@columns + ',[' + Subject + ']', '[' + Subject + ']')
FROM (SELECT DISTINCT Subject FROM Students) AS Subjects

-- Build dynamic SQL
SET @sql = '
SELECT StudentName, ' + @columns + '
FROM (
    SELECT StudentName, Subject, Score
    FROM Students
) AS SourceTable
PIVOT (
    MAX(Score)
    FOR Subject IN (' + @columns + ')
) AS PivotTable'

EXEC sp_executesql @sql
```

### **Complex Example: Employee Department Salary**

```sql
-- Original data
CREATE TABLE EmployeeSalary (
    EmployeeName VARCHAR(50),
    Department VARCHAR(50),
    Salary DECIMAL(10,2)
);

INSERT INTO EmployeeSalary VALUES
('John', 'IT', 75000),
('John', 'Sales', 0),
('Jane', 'IT', 80000),
('Jane', 'HR', 70000),
('Bob', 'Sales', 65000);

-- Transpose to show departments as columns
SELECT 
    EmployeeName,
    ISNULL([IT], 0) AS IT_Salary,
    ISNULL([Sales], 0) AS Sales_Salary,
    ISNULL([HR], 0) AS HR_Salary
FROM (
    SELECT EmployeeName, Department, Salary
    FROM EmployeeSalary
) AS SourceTable
PIVOT (
    SUM(Salary)
    FOR Department IN ([IT], [Sales], [HR])
) AS PivotTable;
```

### **Using STRING_AGG for Concatenation (SQL Server 2017+)**

```sql
-- Combine multiple rows into single column
SELECT 
    StudentName,
    STRING_AGG(CONCAT(Subject, ':', Score), ', ') AS SubjectScores
FROM Students
GROUP BY StudentName;

-- Result:
-- StudentName | SubjectScores
-- ------------|--------------------------------
-- John        | Math:85, Science:92, English:78
-- Jane        | Math:90, Science:88, English:95
```

### **Cross-Database Compatibility**

#### **MySQL Version**
```sql
-- MySQL doesn't have PIVOT, use CASE WHEN
SELECT 
    StudentName,
    MAX(CASE WHEN Subject = 'Math' THEN Score END) AS Math,
    MAX(CASE WHEN Subject = 'Science' THEN Score END) AS Science,
    MAX(CASE WHEN Subject = 'English' THEN Score END) AS English
FROM Students
GROUP BY StudentName;
```

#### **PostgreSQL Version**
```sql
-- PostgreSQL using crosstab (requires tablefunc extension)
CREATE EXTENSION IF NOT EXISTS tablefunc;

SELECT * FROM crosstab(
    'SELECT StudentName, Subject, Score FROM Students ORDER BY 1,2',
    'VALUES (''Math''), (''Science''), (''English'')'
) AS ct(StudentName text, Math int, Science int, English int);
```

**Key Points:**
- PIVOT converts rows to columns
- UNPIVOT converts columns to rows
- CASE WHEN is universally supported
- PIVOT/UNPIVOT are database-specific
- Use GROUP BY with aggregate functions for PIVOT
- UNION ALL works for simple UNPIVOT scenarios

[ðŸ”¼ Back to Top](#table-of-contents)

***

## 10. What is Angular Guards and their types?

**Angular Guards** are interfaces that control navigation and access to routes. They act as security checkpoints to determine whether a route can be activated, deactivated, or loaded.

### **Types of Guards**

#### **1. CanActivate Guard**
Controls whether a route can be activated.

```typescript
import { Injectable } from '@angular/core';
import { CanActivate, Router, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { AuthService } from './auth.service';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {
  
  constructor(
    private authService: AuthService,
    private router: Router
  ) {}
  
  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): boolean {
    if (this.authService.isAuthenticated()) {
      return true;
    }
    
    this.router.navigate(['/login']);
    return false;
  }
}

// Route configuration
const routes: Routes = [
  {
    path: 'dashboard',
    component: DashboardComponent,
    canActivate: [AuthGuard]
  }
];
```

#### **2. CanActivateChild Guard**
Controls whether child routes can be activated.

```typescript
@Injectable({
  providedIn: 'root'
})
export class AdminGuard implements CanActivateChild {
  
  constructor(private authService: AuthService) {}
  
  canActivateChild(
    childRoute: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): boolean {
    return this.authService.hasRole('admin');
  }
}

// Route configuration
const routes: Routes = [
  {
    path: 'admin',
    component: AdminComponent,
    canActivateChild: [AdminGuard],
    children: [
      { path: 'users', component: UsersComponent },
      { path: 'settings', component: SettingsComponent }
    ]
  }
];
```

#### **3. CanDeactivate Guard**
Controls whether a route can be left (navigated away from).

```typescript
export interface CanComponentDeactivate {
  canDeactivate(): boolean | Observable | Promise;
}

@Injectable({
  providedIn: 'root'
})
export class UnsavedChangesGuard implements CanDeactivate {
  
  canDeactivate(
    component: CanComponentDeactivate,
    currentRoute: ActivatedRouteSnapshot,
    currentState: RouterStateSnapshot,
    nextState?: RouterStateSnapshot
  ): boolean | Observable | Promise {
    
    if (component.canDeactivate && !component.canDeactivate()) {
      return confirm('You have unsaved changes. Do you want to leave?');
    }
    return true;
  }
}

// Component implementation
@Component({
  template: `
    
      
      Save
    
  `
})
export class EditComponent implements CanComponentDeactivate {
  data: string = '';
  saved: boolean = false;
  
  canDeactivate(): boolean {
    return this.saved || !this.data;
  }
  
  save() {
    // Save logic
    this.saved = true;
  }
}

// Route configuration
const routes: Routes = [
  {
    path: 'edit',
    component: EditComponent,
    canDeactivate: [UnsavedChangesGuard]
  }
];
```

#### **4. CanLoad Guard**
Controls whether a module can be loaded (lazy loading).

```typescript
@Injectable({
  providedIn: 'root'
})
export class FeatureGuard implements CanLoad {
  
  constructor(private featureService: FeatureService) {}
  
  canLoad(route: Route, segments: UrlSegment[]): boolean {
    return this.featureService.isFeatureEnabled('premium');
  }
}

// Route configuration
const routes: Routes = [
  {
    path: 'premium',
    loadChildren: () => import('./premium/premium.module').then(m => m.PremiumModule),
    canLoad: [FeatureGuard]
  }
];
```

#### **5. Resolve Guard**
Pre-fetches data before route activation.

```typescript
@Injectable({
  providedIn: 'root'
})
export class UserResolver implements Resolve {
  
  constructor(private userService: UserService, private router: Router) {}
  
  resolve(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): Observable | Promise | User {
    const userId = route.paramMap.get('id');
    
    return this.userService.getUser(userId).pipe(
      catchError(() => {
        this.router.navigate(['/not-found']);
        return EMPTY;
      })
    );
  }
}

// Component using resolved data
@Component({
  template: `{{ user.name }}`
})
export class UserDetailComponent implements OnInit {
  user: User;
  
  constructor(private route: ActivatedRoute) {}
  
  ngOnInit() {
    this.user = this.route.snapshot.data['user'];
  }
}

// Route configuration
const routes: Routes = [
  {
    path: 'user/:id',
    component: UserDetailComponent,
    resolve: { user: UserResolver }
  }
];
```

### **Advanced Guard Examples**

#### **Role-Based Guard**
```typescript
@Injectable({
  providedIn: 'root'
})
export class RoleGuard implements CanActivate {
  
  constructor(
    private authService: AuthService,
    private router: Router
  ) {}
  
  canActivate(route: ActivatedRouteSnapshot): boolean {
    const expectedRoles = route.data['roles'] as string[];
    const userRoles = this.authService.getUserRoles();
    
    const hasRole = expectedRoles.some(role => userRoles.includes(role));
    
    if (!hasRole) {
      this.router.navigate(['/unauthorized']);
      return false;
    }
    
    return true;
  }
}

// Route with roles
const routes: Routes = [
  {
    path: 'admin',
    component: AdminComponent,
    canActivate: [AuthGuard, RoleGuard],
    data: { roles: ['admin', 'moderator'] }
  }
];
```

#### **Async Guard with HTTP**
```typescript
@Injectable({
  providedIn: 'root'
})
export class PermissionGuard implements CanActivate {
  
  constructor(
    private http: HttpClient,
    private router: Router
  ) {}
  
  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): Observable {
    const resource = route.data['resource'];
    
    return this.http.get(`/api/permissions/${resource}`).pipe(
      map(response => {
        if (!response.hasPermission) {
          this.router.navigate(['/access-denied']);
          return false;
        }
        return true;
      }),
      catchError(() => {
        this.router.navigate(['/error']);
        return of(false);
      })
    );
  }
}
```

#### **Functional Guards (Angular 14+)**
```typescript
// Functional guard approach
export const authGuard: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const router = inject(Router);
  
  if (authService.isAuthenticated()) {
    return true;
  }
  
  return router.createUrlTree(['/login']);
};

// Route configuration
const routes: Routes = [
  {
    path: 'protected',
    component: ProtectedComponent,
    canActivate: [authGuard]
  }
];
```

**Guard Execution Order:**
1. CanDeactivate (on current route)
2. CanLoad (for lazy modules)
3. CanActivateChild
4. CanActivate
5. Resolve

**Best Practices:**
- Keep guards lightweight and focused
- Use observables for async operations
- Handle errors gracefully
- Provide user feedback for denied access
- Use functional guards for simpler logic

[ðŸ”¼ Back to Top](#table-of-contents)

***

## 11. Performance improvement for microservices database operations

When dealing with performance issues in microservice database operations, especially for bulk inserts/retrievals, there are several optimization strategies:

### **Database-Level Optimizations**

#### **1. Bulk Insert Operations**
```csharp
// Instead of individual inserts
public async Task InsertRowsSlowly(List entities)
{
    foreach (var entity in entities)
    {
        context.Entities.Add(entity);
        await context.SaveChangesAsync(); // Don't do this!
    }
}

// Use bulk operations
public async Task InsertRowsBulk(List entities)
{
    context.Entities.AddRange(entities);
    await context.SaveChangesAsync(); // Single transaction
}

// Or use SqlBulkCopy for massive datasets
public async Task BulkInsertWithSqlBulkCopy(DataTable dataTable)
{
    using var bulkCopy = new SqlBulkCopy(connectionString);
    bulkCopy.DestinationTableName = "Entities";
    bulkCopy.BatchSize = 1000;
    await bulkCopy.WriteToServerAsync(dataTable);
}
```

#### **2. Batch Processing**
```csharp
public async Task ProcessInBatches(List items, int batchSize = 1000)
{
    for (int i = 0; i (List batch)
{
    using var scope = serviceProvider.CreateScope();
    var context = scope.ServiceProvider.GetRequiredService();
    
    context.AddRange(batch);
    await context.SaveChangesAsync();
}
```

### **Connection and Query Optimizations**

#### **3. Connection Pooling**
```csharp
// Configure connection pooling
services.AddDbContext(options =>
{
    options.UseSqlServer(connectionString, sqlOptions =>
    {
        sqlOptions.CommandTimeout(300); // 5 minutes
    });
});

// Connection string optimizations
"Server=server;Database=db;Pooling=true;Min Pool Size=5;Max Pool Size=100;Connection Timeout=30;"
```

#### **4. Compiled Queries**
```csharp
private static readonly Func> GetEntitiesQuery =
    EF.CompileQuery((DbContext context, int departmentId) =>
        context.Entities.Where(e => e.DepartmentId == departmentId));

public async Task> GetEntitiesOptimized(int departmentId)
{
    return await GetEntitiesQuery(context, departmentId).ToListAsync();
}
```

### **Caching Strategies**

#### **5. Memory Caching**
```csharp
public class CachedDataService
{
    private readonly IMemoryCache cache;
    private readonly IDataService dataService;
    
    public async Task> GetCachedEntities(int id)
    {
        var cacheKey = $"entities_{id}";
        
        if (!cache.TryGetValue(cacheKey, out List entities))
        {
            entities = await dataService.GetEntities(id);
            
            var cacheOptions = new MemoryCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30),
                SlidingExpiration = TimeSpan.FromMinutes(5)
            };
            
            cache.Set(cacheKey, entities, cacheOptions);
        }
        
        return entities;
    }
}
```

#### **6. Redis Distributed Cache**
```csharp
public class DistributedCacheService
{
    private readonly IDistributedCache cache;
    
    public async Task GetOrSetAsync(string key, Func> getItem, TimeSpan? expiry = null)
    {
        var cachedValue = await cache.GetStringAsync(key);
        
        if (!string.IsNullOrEmpty(cachedValue))
        {
            return JsonSerializer.Deserialize(cachedValue);
        }
        
        var item = await getItem();
        var serializedItem = JsonSerializer.Serialize(item);
        
        var options = new DistributedCacheEntryOptions();
        if (expiry.HasValue)
            options.SetAbsoluteExpiration(expiry.Value);
        
        await cache.SetStringAsync(key, serializedItem, options);
        return item;
    }
}
```

### **Asynchronous Processing**

#### **7. Background Job Processing**
```csharp
// Using Hangfire for background jobs
public class DataProcessingService
{
    private readonly IBackgroundJobClient backgroundJobs;
    
    public async Task QueueBulkInsert(List entities)
    {
        // Return immediately, process in background
        var jobId = backgroundJobs.Enqueue(() => ProcessBulkInsert(entities));
        return jobId;
    }
    
    [Queue("bulk-operations")]
    public async Task ProcessBulkInsert(List entities)
    {
        const int batchSize = 1000;
        
        for (int i = 0; i  entities)
    {
        var chunks = entities.Chunk(100); // Split into smaller chunks
        
        foreach (var chunk in chunks)
        {
            var message = new ProcessDataMessage { Entities = chunk.ToList() };
            await messageBus.PublishAsync(message);
        }
    }
}

// Consumer (Microservice 1)
public class DataConsumer : IMessageHandler
{
    public async Task HandleAsync(ProcessDataMessage message)
    {
        await ProcessEntities(message.Entities);
    }
}
```

### **Database Design Optimizations**

#### **9. Indexing Strategy**
```sql
-- Add indexes for frequently queried columns
CREATE NONCLUSTERED INDEX IX_Entity_DepartmentId_CreatedDate 
ON Entities (DepartmentId, CreatedDate)
INCLUDE (Name, Status);

-- Covering indexes for common queries
CREATE NONCLUSTERED INDEX IX_Entity_Search 
ON Entities (Status, DepartmentId)
INCLUDE (Id, Name, CreatedDate);
```

#### **10. Partitioning**
```sql
-- Partition large tables by date
CREATE PARTITION FUNCTION PF_ByMonth(datetime2)
AS RANGE RIGHT FOR VALUES 
('2024-01-01', '2024-02-01', '2024-03-01', ...);

CREATE PARTITION SCHEME PS_ByMonth
AS PARTITION PF_ByMonth
TO (FG1, FG2, FG3, ...);

CREATE TABLE Entities (
    Id int IDENTITY(1,1),
    CreatedDate datetime2,
    ...
) ON PS_ByMonth(CreatedDate);
```

### **API Response Optimization**

#### **11. Pagination and Filtering**
```csharp
public class OptimizedDataController : ControllerBase
{
    [HttpGet]
    public async Task> GetEntities(
        [FromQuery] int page = 1,
        [FromQuery] int pageSize = 50,
        [FromQuery] string filter = null)
    {
        var query = context.Entities.AsNoTracking(); // No change tracking
        
        if (!string.IsNullOrEmpty(filter))
        {
            query = query.Where(e => e.Name.Contains(filter));
        }
        
        var totalCount = await query.CountAsync();
        var entities = await query
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync();
        
        return new PagedResult
        {
            Data = entities,
            TotalCount = totalCount,
            Page = page,
            PageSize = pageSize
        };
    }
}
```

### **Monitoring and Profiling**

#### **12. Performance Monitoring**
```csharp
public class PerformanceMonitoringService
{
    private readonly ILogger logger;
    
    public async Task ExecuteWithMonitoring(Func> operation, string operationName)
    {
        var stopwatch = Stopwatch.StartNew();
        
        try
        {
            var result = await operation();
            stopwatch.Stop();
            
            logger.LogInformation("Operation {OperationName} completed in {ElapsedMs}ms", 
                operationName, stopwatch.ElapsedMilliseconds);
            
            return result;
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            logger.LogError(ex, "Operation {OperationName} failed after {ElapsedMs}ms", 
                operationName, stopwatch.ElapsedMilliseconds);
            throw;
        }
    }
}
```

**Performance Improvement Summary:**
1. **Bulk operations** instead of individual operations
2. **Batch processing** for large datasets
3. **Caching** frequently accessed data
4. **Asynchronous processing** for non-critical operations
5. **Database optimization** (indexes, partitioning)
6. **Connection pooling** and query optimization
7. **Pagination** to limit data transfer
8. **Monitoring** to identify bottlenecks

[ðŸ”¼ Back to Top](#table-of-contents)

***

## 12. How do you implement JWT in .NET Core Web API

Implementing JWT authentication in .NET Core Web API involves several steps including token generation, validation, and securing endpoints.

### **1. Install Required Packages**

```bash
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
dotnet add package System.IdentityModel.Tokens.Jwt
```

### **2. JWT Configuration Model**

```csharp
public class JwtSettings
{
    public string Secret { get; set; }
    public string Issuer { get; set; }
    public string Audience { get; set; }
    public int ExpirationInMinutes { get; set; }
}
```

### **3. Configure JWT in Program.cs**

```csharp
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Text;

var builder = WebApplication.CreateBuilder(args);

// Configure JWT settings
var jwtSettings = builder.Configuration.GetSection("JwtSettings").Get();
builder.Services.Configure(builder.Configuration.GetSection("JwtSettings"));

// Add JWT Authentication
builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = true,
        ValidateAudience = true,
        ValidateLifetime = true,
        ValidateIssuerSigningKey = true,
        ValidIssuer = jwtSettings.Issuer,
        ValidAudience = jwtSettings.Audience,
        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtSettings.Secret)),
        ClockSkew = TimeSpan.Zero // Remove default 5-minute tolerance
    };
});

builder.Services.AddAuthorization();
builder.Services.AddControllers();

var app = builder.Build();

// Configure pipeline
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();

app.Run();
```

### **4. appsettings.json Configuration**

```json
{
  "JwtSettings": {
    "Secret": "YourSuperSecretKeyThatIsAtLeast32CharactersLong!",
    "Issuer": "YourAppName",
    "Audience": "YourAppUsers",
    "ExpirationInMinutes": 60
  }
}
```

### **5. JWT Service Implementation**

```csharp
public interface IJwtService
{
    string GenerateToken(User user);
    ClaimsPrincipal ValidateToken(string token);
    string GenerateRefreshToken();
}

public class JwtService : IJwtService
{
    private readonly JwtSettings _jwtSettings;
    
    public JwtService(IOptions jwtSettings)
    {
        _jwtSettings = jwtSettings.Value;
    }
    
    public string GenerateToken(User user)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(_jwtSettings.Secret);
        
        var claims = new List
        {
            new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
            new Claim(ClaimTypes.Name, user.Username),
            new Claim(ClaimTypes.Email, user.Email),
            new Claim("custom_claim", "custom_value")
        };
        
        // Add role claims
        foreach (var role in user.Roles)
        {
            claims.Add(new Claim(ClaimTypes.Role, role));
        }
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(claims),
            Expires = DateTime.UtcNow.AddMinutes(_jwtSettings.ExpirationInMinutes),
            Issuer = _jwtSettings.Issuer,
            Audience = _jwtSettings.Audience,
            SigningCredentials = new SigningCredentials(
                new SymmetricSecurityKey(key),
                SecurityAlgorithms.HmacSha256Signature)
        };
        
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
    
    public ClaimsPrincipal ValidateToken(string token)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(_jwtSettings.Secret);
        
        try
        {
            var principal = tokenHandler.ValidateToken(token, new TokenValidationParameters
            {
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(key),
                ValidateIssuer = true,
                ValidIssuer = _jwtSettings.Issuer,
                ValidateAudience = true,
                ValidAudience = _jwtSettings.Audience,
                ValidateLifetime = true,
                ClockSkew = TimeSpan.Zero
            }, out SecurityToken validatedToken);
            
            return principal;
        }
        catch
        {
            return null;
        }
    }
    
    public string GenerateRefreshToken()
    {
        var randomNumber = new byte[32];
        using var rng = RandomNumberGenerator.Create();
        rng.GetBytes(randomNumber);
        return Convert.ToBase64String(randomNumber);
    }
}
```

### **6. Authentication Controller**

```csharp
[ApiController]
[Route("api/[controller]")]
public class AuthController : ControllerBase
{
    private readonly IJwtService _jwtService;
    private readonly IUserService _userService;
    
    public AuthController(IJwtService jwtService, IUserService userService)
    {
        _jwtService = jwtService;
        _userService = userService;
    }
    
    [HttpPost("login")]
    public async Task Login([FromBody] LoginRequest request)
    {
        var user = await _userService.ValidateUserAsync(request.Username, request.Password);
        
        if (user == null)
        {
            return Unauthorized(new { message = "Invalid credentials" });
        }
        
        var token = _jwtService.GenerateToken(user);
        var refreshToken = _jwtService.GenerateRefreshToken();
        
        // Store refresh token in database
        await _userService.SaveRefreshTokenAsync(user.Id, refreshToken);
        
        return Ok(new LoginResponse
        {
            Token = token,
            RefreshToken = refreshToken,
            Expiration = DateTime.UtcNow.AddMinutes(60),
            User = new UserDto
            {
                Id = user.Id,
                Username = user.Username,
                Email = user.Email,
                Roles = user.Roles
            }
        });
    }
    
    [HttpPost("refresh")]
    public async Task RefreshToken([FromBody] RefreshTokenRequest request)
    {
        var user = await _userService.GetUserByRefreshTokenAsync(request.RefreshToken);
        
        if (user == null)
        {
            return Unauthorized(new { message = "Invalid refresh token" });
        }
        
        var newToken = _jwtService.GenerateToken(user);
        var newRefreshToken = _jwtService.GenerateRefreshToken();
        
        await _userService.SaveRefreshTokenAsync(user.Id, newRefreshToken);
        
        return Ok(new LoginResponse
        {
            Token = newToken,
            RefreshToken = newRefreshToken,
            Expiration = DateTime.UtcNow.AddMinutes(60)
        });
    }
    
    [HttpPost("logout")]
    [Authorize]
    public async Task Logout()
    {
        var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        
        if (userId != null)
        {
            await _userService.RevokeRefreshTokenAsync(int.Parse(userId));
        }
        
        return Ok(new { message = "Logged out successfully" });
    }
}
```

### **7. Protected Controller Example**

```csharp
[ApiController]
[Route("api/[controller]")]
[Authorize] // Requires authentication for all actions
public class UsersController : ControllerBase
{
    [HttpGet]
    public IActionResult GetAllUsers()
    {
        // Only authenticated users can access
        var currentUserId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        var currentUserName = User.FindFirst(ClaimTypes.Name)?.Value;
        
        return Ok(new { message = $"Hello {currentUserName}" });
    }
    
    [HttpGet("admin-only")]
    [Authorize(Roles = "Admin")] // Requires specific role
    public IActionResult AdminOnlyEndpoint()
    {
        return Ok(new { message = "This is admin-only content" });
    }
    
    [HttpGet("claims")]
    public IActionResult GetClaims()
    {
        var claims = User.Claims.Select(c => new { c.Type, c.Value });
        return Ok(claims);
    }
}
```

### **8. Custom Authorization Policies**

```csharp
// In Program.cs
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("RequireAdminRole", policy =>
        policy.RequireRole("Admin"));
        
    options.AddPolicy("RequireMinimumAge", policy =>
        policy.RequireClaim("age", "18", "19", "20")); // Must be 18+
        
    options.AddPolicy("RequireEmailVerified", policy =>
        policy.RequireClaim("email_verified", "true"));
});

// Usage in controller
[Authorize(Policy = "RequireEmailVerified")]
public IActionResult VerifiedUsersOnly()
{
    return Ok("Email verified users only");
}
```

### **9. Request/Response Models**

```csharp
public class LoginRequest
{
    public string Username { get; set; }
    public string Password { get; set; }
}

public class LoginResponse
{
    public string Token { get; set; }
    public string RefreshToken { get; set; }
    public DateTime Expiration { get; set; }
    public UserDto User { get; set; }
}

public class RefreshTokenRequest
{
    public string RefreshToken { get; set; }
}

public class UserDto
{
    public int Id { get; set; }
    public string Username { get; set; }
    public string Email { get; set; }
    public List Roles { get; set; }
}
```

### **10. Middleware for Additional Security**

```csharp
public class JwtMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IJwtService _jwtService;
    
    public JwtMiddleware(RequestDelegate next, IJwtService jwtService)
    {
        _next = next;
        _jwtService = jwtService;
    }
    
    public async Task Invoke(HttpContext context)
    {
        var token = context.Request.Headers["Authorization"]
            .FirstOrDefault()?.Split(" ").Last();
        
        if (token != null)
        {
            var principal = _jwtService.ValidateToken(token);
            if (principal != null)
            {
                context.User = principal;
            }
        }
        
        await _next(context);
    }
}

// Register middleware
app.UseMiddleware();
```

**Security Best Practices:**
1. Use strong secret keys (at least 256 bits)
2. Implement token expiration and refresh mechanism
3. Store refresh tokens securely in database
4. Use HTTPS in production
5. Implement rate limiting for login attempts
6. Log authentication events
7. Validate and sanitize all inputs

[ðŸ”¼ Back to Top](#table-of-contents)

***

## 13. What is cache? How do implement it? What are different types

**Cache** is a high-speed storage layer that stores frequently accessed data to reduce latency and improve application performance by avoiding expensive operations like database queries or API calls.

### **Types of Caching**

#### **1. Memory Cache (In-Process)**
Stores data in the application's memory space.

```csharp
// Configure Memory Cache
services.AddMemoryCache();

// Memory Cache Service
public class MemoryCacheService
{
    private readonly IMemoryCache _cache;
    
    public MemoryCacheService(IMemoryCache cache)
    {
        _cache = cache;
    }
    
    public T Get(string key)
    {
        return _cache.Get(key);
    }
    
    public void Set(string key, T value, TimeSpan expiration)
    {
        var options = new MemoryCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = expiration,
            SlidingExpiration = TimeSpan.FromMinutes(5), // Reset expiration on access
            Priority = CacheItemPriority.Normal
        };
        
        _cache.Set(key, value, options);
    }
    
    public async Task GetOrSetAsync(string key, Func> getItem, TimeSpan? expiration = null)
    {
        if (_cache.TryGetValue(key, out T cachedValue))
        {
            return cachedValue;
        }
        
        var item = await getItem();
        var expirationTime = expiration ?? TimeSpan.FromMinutes(30);
        
        Set(key, item, expirationTime);
        return item;
    }
    
    public void Remove(string key)
    {
        _cache.Remove(key);
    }
}

// Usage Example
public class ProductService
{
    private readonly MemoryCacheService _cache;
    private readonly IProductRepository _repository;
    
    public async Task GetProductAsync(int id)
    {
        var cacheKey = $"product_{id}";
        
        return await _cache.GetOrSetAsync(cacheKey, 
            async () => await _repository.GetByIdAsync(id),
            TimeSpan.FromMinutes(15));
    }
}
```

#### **2. Distributed Cache (Redis)**
Shared cache across multiple application instances.

```csharp
// Install Redis package
// dotnet add package Microsoft.Extensions.Caching.StackExchangeRedis

// Configure Redis
services.AddStackExchangeRedisCache(options =>
{
    options.Configuration = "localhost:6379";
    options.InstanceName = "MyApp";
});

// Distributed Cache Service
public class DistributedCacheService
{
    private readonly IDistributedCache _cache;
    
    public DistributedCacheService(IDistributedCache cache)
    {
        _cache = cache;
    }
    
    public async Task GetAsync(string key)
    {
        var cachedValue = await _cache.GetStringAsync(key);
        
        if (string.IsNullOrEmpty(cachedValue))
            return default(T);
        
        return JsonSerializer.Deserialize(cachedValue);
    }
    
    public async Task SetAsync(string key, T value, TimeSpan? expiration = null)
    {
        var serializedValue = JsonSerializer.Serialize(value);
        
        var options = new DistributedCacheEntryOptions();
        if (expiration.HasValue)
        {
            options.SetAbsoluteExpiration(expiration.Value);
        }
        
        await _cache.SetStringAsync(key, serializedValue, options);
    }
    
    public async Task GetOrSetAsync(string key, Func> getItem, TimeSpan? expiration = null)
    {
        var cachedValue = await GetAsync(key);
        
        if (cachedValue != null)
            return cachedValue;
        
        var item = await getItem();
        await SetAsync(key, item, expiration);
        
        return item;
    }
    
    public async Task RemoveAsync(string key)
    {
        await _cache.RemoveAsync(key);
    }
}
```

#### **3. HTTP Response Caching**
Caches HTTP responses at different levels.

```csharp
// Configure Response Caching
services.AddResponseCaching();

// In Program.cs
app.UseResponseCaching();

// Controller with Response Caching
[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    [HttpGet]
    [ResponseCache(Duration = 300)] // Cache for 5 minutes
    public async Task GetProducts()
    {
        var products = await _productService.GetAllAsync();
        return Ok(products);
    }
    
    [HttpGet("{id}")]
    [ResponseCache(Duration = 600, VaryByQueryKeys = new[] { "id" })]
    public async Task GetProduct(int id)
    {
        var product = await _productService.GetByIdAsync(id);
        return Ok(product);
    }
    
    [HttpGet("no-cache")]
    [ResponseCache(NoStore = true, Duration = 0)]
    public IActionResult GetRealTimeData()
    {
        return Ok(new { timestamp = DateTime.UtcNow });
    }
}
```

#### **4. Output Caching (.NET 7+)**
Modern replacement for Response Caching with more features.

```csharp
// Configure Output Caching
services.AddOutputCache(options =>
{
    options.AddBasePolicy(builder => 
        builder.Expire(TimeSpan.FromMinutes(10)));
        
    options.AddPolicy("short-cache", builder =>
        builder.Expire(TimeSpan.FromMinutes(1)));
        
    options.AddPolicy("vary-by-user", builder =>
        builder.VaryByValue((context, key) => 
            new KeyValuePair("user", context.User.Identity.Name))
               .Expire(TimeSpan.FromMinutes(5)));
});

app.UseOutputCache();

// Controller with Output Caching
[ApiController]
[Route("api/[controller]")]
public class DataController : ControllerBase
{
    [HttpGet]
    [OutputCache(Duration = 300)] // 5 minutes
    public IActionResult GetData()
    {
        return Ok(new { data = "cached data", timestamp = DateTime.UtcNow });
    }
    
    [HttpGet("user-specific")]
    [OutputCache(PolicyName = "vary-by-user")]
    public IActionResult GetUserData()
    {
        return Ok(new { user = User.Identity.Name, data = "user-specific data" });
    }
}
```

### **Advanced Caching Patterns**

#### **5. Cache-Aside Pattern**
```csharp
public class CacheAsideService
{
    private readonly IDistributedCache _cache;
    private readonly IRepository _repository;
    
    public async Task GetAsync(int id)
    {
        var cacheKey = $"{typeof(T).Name}_{id}";
        
        // Try to get from cache first
        var cached = await _cache.GetAsync(cacheKey);
        if (cached != null)
            return cached;
        
        // If not in cache, get from database
        var item = await _repository.GetByIdAsync(id);
        
        // Store in cache for future requests
        if (item != null)
        {
            await _cache.SetAsync(cacheKey, item, TimeSpan.FromMinutes(15));
        }
        
        return item;
    }
    
    public async Task UpdateAsync(T item)
    {
        // Update in database
        await _repository.UpdateAsync(item);
        
        // Invalidate cache
        var cacheKey = $"{typeof(T).Name}_{item.Id}";
        await _cache.RemoveAsync(cacheKey);
    }
}
```

#### **6. Write-Through Cache**
```csharp
public class WriteThroughCacheService
{
    private readonly IDistributedCache _cache;
    private readonly IRepository _repository;
    
    public async Task CreateAsync(T item)
    {
        // Write to database first
        var created = await _repository.CreateAsync(item);
        
        // Then write to cache
        var cacheKey = $"{typeof(T).Name}_{created.Id}";
        await _cache.SetAsync(cacheKey, created, TimeSpan.FromMinutes(15));
        
        return created;
    }
}
```

#### **7. Write-Behind Cache**
```csharp
public class WriteBehindCacheService
{
    private readonly IDistributedCache _cache;
    private readonly IBackgroundTaskQueue _taskQueue;
    
    public async Task UpdateAsync(T item)
    {
        var cacheKey = $"{typeof(T).Name}_{item.Id}";
        
        // Update cache immediately
        await _cache.SetAsync(cacheKey, item, TimeSpan.FromMinutes(15));
        
        // Queue database update for later
        _taskQueue.QueueBackgroundWorkItem(async token =>
        {
            await _repository.UpdateAsync(item);
        });
    }
}
```

### **Caching with Decorators**

#### **8. Decorator Pattern for Caching**
```csharp
public interface IProductService
{
    Task GetByIdAsync(int id);
    Task> GetAllAsync();
}

public class ProductService : IProductService
{
    private readonly IProductRepository _repository;
    
    public async Task GetByIdAsync(int id)
    {
        return await _repository.GetByIdAsync(id);
    }
    
    public async Task> GetAllAsync()
    {
        return await _repository.GetAllAsync();
    }
}

public class CachedProductService : IProductService
{
    private readonly IProductService _productService;
    private readonly IDistributedCache _cache;
    
    public CachedProductService(IProductService productService, IDistributedCache cache)
    {
        _productService = productService;
        _cache = cache;
    }
    
    public async Task GetByIdAsync(int id)
    {
        var cacheKey = $"product_{id}";
        var cached = await _cache.GetAsync(cacheKey);
        
        if (cached != null)
            return cached;
        
        var product = await _productService.GetByIdAsync(id);
        
        if (product != null)
        {
            await _cache.SetAsync(cacheKey, product, TimeSpan.FromMinutes(15));
        }
        
        return product;
    }
    
    public async Task> GetAllAsync()
    {
        const string cacheKey = "all_products";
        var cached = await _cache.GetAsync>(cacheKey);
        
        if (cached != null)
            return cached;
        
        var products = await _productService.GetAllAsync();
        await _cache.SetAsync(cacheKey, products, TimeSpan.FromMinutes(5));
        
        return products;
    }
}

// Register services
services.AddScoped();
services.Decorate();
```

### **Cache Invalidation Strategies**

#### **9. Tag-Based Cache Invalidation**
```csharp
public class TaggedCacheService
{
    private readonly IDistributedCache _cache;
    private readonly Dictionary> _tagToKeys = new();
    
    public async Task SetAsync(string key, T value, string[] tags, TimeSpan expiration)
    {
        await _cache.SetAsync(key, value, expiration);
        
        // Track tags
        foreach (var tag in tags)
        {
            if (!_tagToKeys.ContainsKey(tag))
                _tagToKeys[tag] = new HashSet();
            
            _tagToKeys[tag].Add(key);
        }
    }
    
    public async Task InvalidateByTagAsync(string tag)
    {
        if (_tagToKeys.TryGetValue(tag, out var keys))
        {
            foreach (var key in keys)
            {
                await _cache.RemoveAsync(key);
            }
            
            _tagToKeys.Remove(tag);
        }
    }
}

// Usage
await taggedCache.SetAsync("product_1", product, new[] { "products", "category_electronics" }, TimeSpan.FromMinutes(15));
await taggedCache.InvalidateByTagAsync("products"); // Invalidates all product caches
```

**Cache Selection Guidelines:**
- **Memory Cache**: Single instance, fast access, limited by memory
- **Distributed Cache**: Multi-instance, network latency, scalable
- **Response Cache**: HTTP responses, browser/proxy caching
- **Output Cache**: Modern, flexible, policy-based

**Best Practices:**
1. Set appropriate expiration times
2. Use cache keys consistently
3. Handle cache misses gracefully
4. Monitor cache hit ratios
5. Implement cache warming for critical data
6. Use cache invalidation strategies
7. Consider cache size and memory usage

[ðŸ”¼ Back to Top](#table-of-contents)

***

## 14. Can we create an object in class for a constructor? Are you sure

Yes, absolutely! You can create objects within a class constructor. This is a common practice in object-oriented programming. Let me show you various scenarios:

### **1. Creating Objects in Constructor**

```csharp
public class OrderService
{
    private readonly EmailService _emailService;
    private readonly List _products;
    private readonly Dictionary _inventory;
    
    public OrderService()
    {
        // Creating objects in constructor
        _emailService = new EmailService();
        _products = new List();
        _inventory = new Dictionary();
        
        // Initialize with default data
        InitializeDefaults();
    }
    
    private void InitializeDefaults()
    {
        _products.Add(new Product { Id = 1, Name = "Default Product" });
        _inventory.Add("default", 100);
    }
}
```

### **2. Complex Object Creation in Constructor**

```csharp
public class DatabaseManager
{
    private readonly IDbConnection _connection;
    private readonly ILogger _logger;
    private readonly CacheManager _cache;
    
    public DatabaseManager(string connectionString)
    {
        // Creating different types of objects
        _connection = new SqlConnection(connectionString);
        _logger = new FileLogger("database.log");
        _cache = new CacheManager(new MemoryCache());
        
        // Initialize connections
        InitializeConnection();
    }
    
    private void InitializeConnection()
    {
        _connection.Open();
        _logger.Log("Database connection established");
    }
}
```

### **3. Factory Pattern in Constructor**

```csharp
public class ReportGenerator
{
    private readonly IReportFormatter _formatter;
    private readonly IDataSource _dataSource;
    
    public ReportGenerator(string reportType, string dataSourceType)
    {
        // Creating objects based on parameters
        _formatter = CreateFormatter(reportType);
        _dataSource = CreateDataSource(dataSourceType);
    }
    
    private IReportFormatter CreateFormatter(string type)
    {
        return type.ToLower() switch
        {
            "pdf" => new PdfFormatter(),
            "excel" => new ExcelFormatter(),
            "csv" => new CsvFormatter(),
            _ => new DefaultFormatter()
        };
    }
    
    private IDataSource CreateDataSource(string type)
    {
        return type.ToLower() switch
        {
            "database" => new DatabaseSource(),
            "api" => new ApiSource(),
            "file" => new FileSource(),
            _ => throw new ArgumentException("Invalid data source type")
        };
    }
}
```

### **4. Composite Objects in Constructor**

```csharp
public class GameEngine
{
    private readonly PhysicsEngine _physics;
    private readonly RenderEngine _renderer;
    private readonly AudioEngine _audio;
    private readonly InputManager _input;
    
    public GameEngine(GameConfiguration config)
    {
        // Creating multiple subsystem objects
        _physics = new PhysicsEngine(config.PhysicsSettings);
        _renderer = new RenderEngine(config.GraphicsSettings);
        _audio = new AudioEngine(config.AudioSettings);
        _input = new InputManager();
        
        // Wire up event handlers
        _input.KeyPressed += OnKeyPressed;
        _physics.CollisionDetected += OnCollision;
    }
    
    private void OnKeyPressed(object sender, KeyEventArgs e)
    {
        // Handle input
    }
    
    private void OnCollision(object sender, CollisionEventArgs e)
    {
        // Handle collision

[1] https://www.calibraint.com/blog/angular-components-interaction-methods
[2] https://www.geeksforgeeks.org/angular-js/component-communication-in-angular/
[3] https://dev.to/mariazayed/subjects-and-behaviorsubjects-in-angular-a-deep-dive-4kf2
[4] https://blog.openreplay.com/services-in-angular--subject-vs-behaviorsubject/
[5] https://www.telerik.com/blogs/implementing-global-error-handler-angular-step-guide
[6] https://yon.fun/angular-error-handle/
[7] https://www.tutscoder.com/post/securely-store-jwt-tokens-angular-apps
[8] https://dev.to/gkoniaris/how-to-securely-store-jwt-tokens-51cf
[9] https://stackoverflow.com/questions/58834437/how-to-pass-authorization-header-token-in-api-call-in-angular
[10] https://code-maze.com/secure-angular-calls-to-webapi-using-access-token/
[11] https://radixweb.com/blog/what-is-new-in-angular-20
[12] https://www.c-metric.com/blog/angular-version-history/
[13] https://www.syncfusion.com/blogs/post/angular-state-management-ngrx
[14] https://ngrx.io
[15] https://www.alibabacloud.com/help/en/maxcompute/use-cases/transpose-rows-to-columns-or-columns-to-rows
[16] https://stackoverflow.com/questions/13372276/simple-way-to-transpose-columns-and-rows-in-sql
[17] https://angular.io/guide/component-interaction
[18] https://www.digitalocean.com/community/tutorials/angular-component-communication
[19] https://www.linkedin.com/pulse/four-efficient-ways-communicate-between-angular-components-bedre-bjx7e
[20] https://www.samarpaninfotech.com/blog/methods-to-share-data-between-angular-components/


# Deloitte | FS | L1 | 2 â€“ Interview Q&A

## Table of Contents
1. [Generic vs Non-Generic Collections](#1-generic-vs-non-generic-collections)
2. [Value from appsettings.json in Controller](#2-value-from-appsettingsjson-in-controller)
3. [Find Index in Array](#3-find-index-in-array)
4. [Sum of 2 Numbers (Generic & Non-generic)](#4-sum-of-2-numbers-generic--non-generic)
5. [SQL Query â€“ Employee Salary > 10,000](#5-sql-query--employee-salary--10000)
6. [String Interpolation](#6-string-interpolation)
7. [Event Binding](#7-event-binding)
8. [Component Communication](#8-component-communication)
9. [Content Projection](#9-content-projection)
10. [Async Pipe](#10-async-pipe)
11. [State Management](#11-state-management)
12. [RxJS Operators](#12-rxjs-operators)
13. [Observable vs Promise](#13-observable-vs-promise)
14. [Subject vs BehaviorSubject](#14-subject-vs-behaviorsubject)
15. [Routing in Angular](#15-routing-in-angular)
16. [Building Blocks of Angular](#16-building-blocks-of-angular)
17. [Providing Services in Angular](#17-providing-services-in-angular)
18. [Dependency Injection](#18-dependency-injection)
19. [Route Guards (CanActivate & CanDeactivate)](#19-route-guards-canactivate--candeactivate)
20. [Angular Lifecycle Hooks](#20-angular-lifecycle-hooks)
21. [Standalone Components](#21-standalone-components)

---

## 1. Generic vs Non-Generic Collections
**Key Insight:** Strong typing boosts code safety and performance.

- **Non-Generic Collections** (e.g., `ArrayList`, `Hashtable`) hold objects as `object` type. This allows mixed types but risks runtime errors and boxing overhead.
- **Generic Collections** (e.g., `List<T>`, `Dictionary<TKey,TValue>`) enforce type safety at compile-time, avoid boxing, and improve scalability.

**Example:**
```csharp
// Non-Generic
ArrayList list = new ArrayList();
list.Add(10);
list.Add("Hello"); // Allowed but risky

// Generic
List<int> numbers = new List<int>();
numbers.Add(10);  // Type-safe and performant
````

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 2. Value from appsettings.json in Controller

**Context:** Centralized configuration in .NET apps.

* Define values in `appsettings.json`.
* Bind config section to strongly-typed class via dependency injection.

**Setup example:**
In `appsettings.json`:

```json
{
  "MyConfig": {
    "AppName": "InterviewPrep"
  }
}
```

In `Program.cs`:

```csharp
builder.Services.Configure<MyConfig>(builder.Configuration.GetSection("MyConfig"));
```

Config model:

```csharp
public class MyConfig {
    public string AppName { get; set; }
}
```

Inject in Controller:

```csharp
public class HomeController : ControllerBase {
    private readonly MyConfig _config;

    public HomeController(IOptions<MyConfig> config) {
        _config = config.Value;
    }

    [HttpGet]
    public string GetName() => _config.AppName; // InterviewPrep
}
```

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 3. Find Index in Array

**Task:** Return index if found, else -1.

```csharp
int[] arr = { 1, 2, 3, 4, 5 };

int IndexOf(int[] array, int target) {
    for (int i = 0; i < array.Length; i++) {
        if (array[i] == target) return i;
    }
    return -1;
}

Console.WriteLine(IndexOf(arr, 3)); // Output: 2
```

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 4. Sum of 2 Numbers (Generic & Non-generic)

**Explain:** Demonstrate flexibility with generics.

```csharp
// Non-Generic
public int SumInt(int a, int b) => a + b;

// Generic (using dynamic to handle operator overload)
public T Sum<T>(T a, T b) => (dynamic)a + (dynamic)b;
```

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 5. SQL Query â€“ Employee Salary > 10,000

**Query:** Join tables by `empId` and filter by salary.

```sql
SELECT T1.empName, T1.empId, T2.empSalary
FROM T1
JOIN T2 ON T1.empId = T2.empId
WHERE T2.empSalary > 10000;
```

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 6. String Interpolation

**Why:** Cleaner and readable string formatting.

```csharp
string name = "Rakesh";
Console.WriteLine($"Hello {name}");
```

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 7. Event Binding

**In Angular:** Bind user events directly to methods.

```html
<button (click)="onClick()">Click Me</button>
```

```typescript
onClick() {
  console.log("Button clicked");
}
```

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 8. Component Communication

**Essential Patterns:**

* `@Input()` â€“ Parent to Child data flow.
* `@Output()` with `EventEmitter` â€“ Child to Parent events.
* Shared service with RxJS Subjects â€“ cross-component communication.
* `ViewChild` / `ViewChildren` - access child component instances.

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 9. Content Projection

**Concept:** Project external content into reusable component templates.

```html
<card>
  <p>Projected content goes here</p>
</card>
```

Uses `<ng-content>` in component template.

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 10. Async Pipe

**Benefit:** Automatically subscribes/unsubscribes to Observables or Promises in templates.

```html
<div *ngIf="data$ | async as data">{{ data }}</div>
```

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 11. State Management

* Simple: Use services with RxJS Subjects.
* Scalable: Libraries like NgRx, Akita, NGXS.
* Helps manage complex app state predictably and efficiently.

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 12. RxJS Operators

* Creation: `of`, `from`
* Transformation: `map`, `mergeMap`, `switchMap`
* Filtering: `filter`, `take`, `debounceTime`
* Combination: `combineLatest`, `forkJoin`

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 13. Observable vs Promise

* **Observable:** supports multiple async values, cancellable, lazy.
* **Promise:** single async value, not cancellable, eager.

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 14. Subject vs BehaviorSubject

* **Subject:** emits only new values.
* **BehaviorSubject:** emits latest value immediately to new subscribers.

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 15. Routing in Angular

* Angular routing uses `RouterModule` to manage navigation and views.

```typescript
import { RouterModule, Routes } from '@angular/router';
```

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 16. Building Blocks of Angular

1. Modules
2. Components
3. Templates
4. Services & Dependency Injection
5. Directives
6. Routing

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 17. Providing Services in Angular

* `providedIn: 'root'` makes service singleton app-wide.
* Providing in module/component limits scope to that injector.

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 18. Dependency Injection

* Core Angular design pattern injecting dependencies rather than instantiating.
* Promotes modular, testable, and maintainable code.

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 19. Route Guards (CanActivate & CanDeactivate)

* **CanActivate**: restricts access to routes.
* **CanDeactivate**: prompts before leaving component to handle unsaved changes.

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 20. Angular Lifecycle Hooks

1. `ngOnChanges` - on input changes
2. `ngOnInit` - init component
3. `ngDoCheck` - custom change detection
4. `ngAfterContentInit` - after projected content init
5. `ngAfterContentChecked` - after projected content checked
6. `ngAfterViewInit` - after view init
7. `ngAfterViewChecked` - after view checked
8. `ngOnDestroy` - cleanup

[ðŸ”¼ Back to Top](#table-of-contents)

---

## 21. Standalone Components

* Introduced Angular 14 for lighter code without NgModules.
* Components marked with `standalone: true` can be bootstrapped standalone.
* Improves modularity and faster development.

[ðŸ”¼ Back to Top](#table-of-contents)

---


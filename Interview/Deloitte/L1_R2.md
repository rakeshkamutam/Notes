

# Deloitte | FS | L1 | 2 â€“ Interview Q&A

ðŸ“‘ Table of Contents
1. Generic vs Non-Generic Collections
2. Value from appsettings.json in Controller
3. Find Index in Array
4. Sum of 2 Numbers (Generic & Non-generic)
5. SQL Query â€“ Employee Salary > 10,000
6. String Interpolation
7. Event Binding
8. Component Communication
9. Content Projection
10. Async Pipe
11. State Management
12. RxJS Operators
13. Observable vs Promise
14. Subject vs BehaviorSubject
15. Routing in Angular
16. Building Blocks of Angular
17. Providing Services in Angular
18. Dependency Injection
19. Route Guards (CanActivate & CanDeactivate)
20. Angular Lifecycle Hooks
21. Standalone Components

---

## 1. Generic vs Non-Generic Collections
Key Insight: Strong typing boosts code safety and performance.

- Non-Generic Collections (e.g., ArrayList, Hashtable) hold objects as object type. This allows mixed types but risks runtime errors and boxing overhead.
- Generic Collections (e.g., List<T>, Dictionary<TKey,TValue>) enforce type safety at compile-time, avoid boxing, and improve scalability.

Example:
```csharp
// Non-Generic
ArrayList list = new ArrayList();
list.Add(10);
list.Add("Hello"); // Allowed but risky

// Generic
List<int> numbers = new List<int>();
numbers.Add(10);  // Type-safe and performant
```

[Back to Top]

---

## 2. Value from appsettings.json in Controller
Context: Centralized configuration in .NET apps.

- Define values in appsettings.json.
- Bind config section to strongly-typed class via dependency injection.

Setup example:
In `appsettings.json`:
```json
{
  "MyConfig": {
    "AppName": "InterviewPrep"
  }
}
```
In `Program.cs`:
```csharp
builder.Services.Configure<MyConfig>(builder.Configuration.GetSection("MyConfig"));
```
Config model:
```csharp
public class MyConfig {
    public string AppName { get; set; }
}
```
Inject in Controller:
```csharp
public class HomeController : ControllerBase {
    private readonly MyConfig _config;
    public HomeController(IOptions<MyConfig> config) {
        _config = config.Value;
    }

    [HttpGet]
    public string GetName() => _config.AppName; // InterviewPrep
}
```

[Back to Top]

---

## 3. Find Index in Array
Task: Return index if found, else -1.

```csharp
int[] arr = { 1, 2, 3, 4, 5 };

int IndexOf(int[] array, int target) {
    for (int i = 0; i < array.Length; i++) {
        if (array[i] == target) return i;
    }
    return -1;
}
Console.WriteLine(IndexOf(arr, 3)); // Output: 2
```

[Back to Top]

---

## 4. Sum of 2 Numbers (Generic & Non-generic)
Explain: Demonstrate flexibility with generics.

```csharp
// Non-Generic
public int SumInt(int a, int b) => a + b;

// Generic (using dynamic to handle operator overload)
public T Sum<T>(T a, T b) => (dynamic)a + (dynamic)b;
```

[Back to Top]

---

## 5. SQL Query â€“ Employee Salary > 10,000
Query: Join tables by empId and filter by salary.

```sql
SELECT T1.empName, T1.empId, T2.empSalary
FROM T1
JOIN T2 ON T1.empId = T2.empId
WHERE T2.empSalary > 10000;
```

[Back to Top]

---

## 6. String Interpolation
Why: Cleaner and readable string formatting.

```csharp
string name = "Rakesh";
Console.WriteLine($"Hello {name}");
```

[Back to Top]

---

## 7. Event Binding
In Angular: Bind user events directly to methods.

Template:
```html
<button (click)="onClick()">Click Me</button>
```
Component:
```ts
onClick() {
  console.log("Button clicked");
}
```

[Back to Top]

---

## 8. Component Communication
Essential Patterns:
- `@Input()` â€“ Parent to Child data flow.
- `@Output()` with `EventEmitter` â€“ Child to Parent events.
- Shared service with RxJS Subjects â€“ cross-component communication.
- `ViewChild` / `ViewChildren` - access child component instances.

[Back to Top]

---

## 9. Content Projection
Concept: Project external content into reusable component templates.

Example:
```html
<card>
  <p>Projected content goes here</p>
</card>
```
Uses `<ng-content>` in component template.

[Back to Top]

---

## 10. Async Pipe
Benefit: Automatically subscribes/unsubscribes to Observables or Promises in templates.

```html
<div *ngIf="data$ | async as data">{{ data }}</div>
```

[Back to Top]

---

## 11. State Management
- Simple: Use services with RxJS Subjects.
- Scalable: Libraries like NgRx, Akita, NGXS.
- Helps manage complex app state predictably and efficiently.

[Back to Top]

---

## 12. RxJS Operators
- Creation: `of`, `from`
- Transformation: `map`, `mergeMap`, `switchMap`
- Filtering: `filter`, `take`, `debounceTime`
- Combination: `combineLatest`, `forkJoin`

[Back to Top]

---

## 13. Observable vs Promise
- Observable: supports multiple async values, cancellable, lazy.
- Promise: single async value, not cancellable, eager.

[Back to Top]

---

## 14. Subject vs BehaviorSubject
- Subject: emits only new values.
- BehaviorSubject: emits latest value immediately to new subscribers.

[Back to Top]

---

## 15. Routing in Angular
- Angular routing uses `RouterModule` to manage navigation and views.

```ts
import { RouterModule, Routes } from '@angular/router';
```

[Back to Top]

---

## 16. Building Blocks of Angular
1. Modules
2. Components
3. Templates
4. Services & Dependency Injection
5. Directives
6. Routing

[Back to Top]

---

## 17. Providing Services in Angular
- `providedIn: 'root'` makes service singleton app-wide.
- Providing in module/component limits scope to that injector.

[Back to Top]

---

## 18. Dependency Injection
- Core Angular design pattern injecting dependencies rather than instantiating.
- Promotes modular, testable, and maintainable code.

[Back to Top]

---

## 19. Route Guards (CanActivate & CanDeactivate)
- `CanActivate`: restricts access to routes.
- `CanDeactivate`: prompts before leaving component to handle unsaved changes.

[Back to Top]

---

## 20. Angular Lifecycle Hooks
1. `ngOnChanges` - on input changes
2. `ngOnInit` - init component
3. `ngDoCheck` - custom change detection
4. `ngAfterContentInit` - after projected content init
5. `ngAfterContentChecked` - after projected content checked
6. `ngAfterViewInit` - after view init
7. `ngAfterViewChecked` - after view checked
8. `ngOnDestroy` - cleanup

[Back to Top]

---

## 21. Standalone Components
- Introduced Angular 14 for lighter code without NgModules.
- Components marked with `standalone: true` can be bootstrapped standalone.
- Improves modularity and faster development.

---


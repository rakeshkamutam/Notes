# Angular 13: Services, Dependency Injection & HTTP Client - Comprehensive Notes

## Table of Contents
1. [Services and Dependency Injection](#services-and-dependency-injection)
2. [Creating and Using Services](#creating-and-using-services)
3. [Hierarchical Injector System](#hierarchical-injector-system)
4. [Provider Scope (root, module, component)](#provider-scope)
5. [Injection Tokens and InjectionToken](#injection-tokens-and-injectiontoken)
6. [Advanced DI Concepts](#advanced-di-concepts)
7. [HTTP and APIs](#http-and-apis)
8. [Angular HttpClient](#angular-httpclient)
9. [HTTP Methods (GET, POST, PUT, DELETE)](#http-methods)
10. [Request Headers and Response Types](#request-headers-and-response-types)
11. [Error Handling for HTTP Requests](#error-handling-for-http-requests)
12. [HTTP Interceptors](#http-interceptors)
13. [Authentication Interceptors](#authentication-interceptors)
14. [Logging Interceptors](#logging-interceptors)
15. [Caching Interceptors](#caching-interceptors)
16. [Best Practices](#best-practices)
17. [Common Patterns](#common-patterns)

---

## Services and Dependency Injection

### What are Services?
Services in Angular are singleton objects that provide specific functionality to components and other services. They follow the **Single Responsibility Principle** and are designed to be reusable across the application.

**Key Characteristics:**
- **Singleton Pattern**: One instance per injector
- **Reusable**: Can be injected into multiple components
- **Testable**: Easy to mock and test
- **Separation of Concerns**: Keep business logic separate from UI logic

### Dependency Injection (DI) Overview
DI is a design pattern where dependencies are provided to a class rather than the class creating them itself. Angular's DI system is hierarchical and uses **Injectors** to manage dependencies.

**Benefits:**
- **Loose Coupling**: Components don't need to know how to create dependencies
- **Testability**: Easy to provide mock dependencies
- **Flexibility**: Can change implementations without modifying consumers
- **Maintainability**: Centralized dependency management

---

## Creating and Using Services

### Basic Service Creation

```typescript
// data.service.ts
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class DataService {
  private dataSubject = new BehaviorSubject<any[]>([]);
  public data$ = this.dataSubject.asObservable();

  constructor() { }

  updateData(newData: any[]): void {
    this.dataSubject.next(newData);
  }

  getCurrentData(): any[] {
    return this.dataSubject.value;
  }
}
```

### Service with HTTP Dependencies

```typescript
// user.service.ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, BehaviorSubject } from 'rxjs';
import { map, tap } from 'rxjs/operators';

interface User {
  id: number;
  name: string;
  email: string;
}

@Injectable({
  providedIn: 'root'
})
export class UserService {
  private baseUrl = 'https://api.example.com/users';
  private usersSubject = new BehaviorSubject<User[]>([]);
  public users$ = this.usersSubject.asObservable();

  constructor(private http: HttpClient) { }

  getUsers(): Observable<User[]> {
    return this.http.get<User[]>(this.baseUrl).pipe(
      tap(users => this.usersSubject.next(users))
    );
  }

  getUserById(id: number): Observable<User> {
    return this.http.get<User>(`${this.baseUrl}/${id}`);
  }

  createUser(user: Partial<User>): Observable<User> {
    return this.http.post<User>(this.baseUrl, user).pipe(
      tap(newUser => {
        const currentUsers = this.usersSubject.value;
        this.usersSubject.next([...currentUsers, newUser]);
      })
    );
  }
}
```

### Using Services in Components

```typescript
// app.component.ts
import { Component, OnInit, OnDestroy } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { UserService } from './services/user.service';

@Component({
  selector: 'app-root',
  template: `
    <div *ngFor="let user of users">
      {{ user.name }} - {{ user.email }}
    </div>
  `
})
export class AppComponent implements OnInit, OnDestroy {
  users: User[] = [];
  private destroy$ = new Subject<void>();

  constructor(private userService: UserService) { }

  ngOnInit(): void {
    this.userService.users$
      .pipe(takeUntil(this.destroy$))
      .subscribe(users => this.users = users);

    this.userService.getUsers().subscribe();
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```

---

## Hierarchical Injector System

### Understanding the Injector Hierarchy

Angular's DI system follows a hierarchical structure:

1. **ModuleInjector Hierarchy**
   - Root Injector (platform-level)
   - Root Module Injector
   - Lazy-loaded Module Injectors

2. **ElementInjector Hierarchy**
   - Component Injectors
   - Directive Injectors

### Resolution Strategy

```typescript
// Angular searches for providers in this order:
// 1. Current ElementInjector
// 2. Parent ElementInjector (up the component tree)
// 3. Current ModuleInjector
// 4. Parent ModuleInjector (up the module hierarchy)
// 5. Root ModuleInjector
```

### Example: Multiple Injector Levels

```typescript
// app.module.ts
@NgModule({
  providers: [
    { provide: 'APP_CONFIG', useValue: { version: '1.0' } }
  ]
})
export class AppModule { }

// feature.module.ts
@NgModule({
  providers: [
    { provide: 'FEATURE_CONFIG', useValue: { feature: 'enabled' } }
  ]
})
export class FeatureModule { }

// parent.component.ts
@Component({
  selector: 'app-parent',
  providers: [
    { provide: 'PARENT_SERVICE', useClass: ParentService }
  ]
})
export class ParentComponent { }

// child.component.ts
@Component({
  selector: 'app-child',
  providers: [
    { provide: 'CHILD_SERVICE', useClass: ChildService }
  ]
})
export class ChildComponent {
  constructor(
    @Inject('CHILD_SERVICE') private childService: any,
    @Inject('PARENT_SERVICE') private parentService: any, // Available from parent
    @Inject('FEATURE_CONFIG') private featureConfig: any, // Available from module
    @Inject('APP_CONFIG') private appConfig: any // Available from root
  ) { }
}
```

---

## Provider Scope

### Root Scope (`providedIn: 'root'`)

```typescript
@Injectable({
  providedIn: 'root'
})
export class GlobalService {
  // Single instance across the entire application
  // Tree-shakable - only included if used
}
```

### Module Scope

```typescript
// Method 1: In service
@Injectable({
  providedIn: FeatureModule
})
export class FeatureService { }

// Method 2: In module providers
@NgModule({
  providers: [FeatureService]
})
export class FeatureModule { }
```

### Component Scope

```typescript
@Component({
  selector: 'app-component',
  providers: [ComponentService] // New instance for each component instance
})
export class MyComponent { }
```

### Practical Example: Different Scopes

```typescript
// notification.service.ts
@Injectable({
  providedIn: 'root'
})
export class NotificationService {
  private notifications: string[] = [];

  addNotification(message: string): void {
    this.notifications.push(message);
  }

  getNotifications(): string[] {
    return [...this.notifications];
  }
}

// logger.service.ts
@Injectable() // No providedIn - must be provided explicitly
export class LoggerService {
  private logs: string[] = [];

  log(message: string): void {
    this.logs.push(`${new Date().toISOString()}: ${message}`);
  }

  getLogs(): string[] {
    return [...this.logs];
  }
}

// Component-level provider
@Component({
  selector: 'app-feature',
  providers: [LoggerService] // Each component gets its own logger
})
export class FeatureComponent {
  constructor(
    private notificationService: NotificationService, // Shared across app
    private loggerService: LoggerService // Unique to this component
  ) { }
}
```

---

## Injection Tokens and InjectionToken

### What are Injection Tokens?

Injection tokens are used to inject primitive values, configuration objects, or when you need to avoid naming conflicts.

### Creating and Using InjectionToken

```typescript
// tokens.ts
import { InjectionToken } from '@angular/core';

export interface AppConfig {
  apiUrl: string;
  production: boolean;
  version: string;
}

export const APP_CONFIG = new InjectionToken<AppConfig>('app.config');

export const API_URL = new InjectionToken<string>('api.url');
```

### Providing Tokens

```typescript
// app.module.ts
import { APP_CONFIG, API_URL } from './tokens';

@NgModule({
  providers: [
    {
      provide: APP_CONFIG,
      useValue: {
        apiUrl: 'https://api.example.com',
        production: false,
        version: '1.0.0'
      }
    },
    {
      provide: API_URL,
      useValue: 'https://api.example.com'
    }
  ]
})
export class AppModule { }
```

### Injecting Tokens

```typescript
// api.service.ts
import { Injectable, Inject } from '@angular/core';
import { APP_CONFIG, AppConfig } from './tokens';

@Injectable({
  providedIn: 'root'
})
export class ApiService {
  constructor(
    @Inject(APP_CONFIG) private config: AppConfig,
    private http: HttpClient
  ) { }

  getData(): Observable<any> {
    return this.http.get(`${this.config.apiUrl}/data`);
  }
}
```

### Multi-Provider Tokens

```typescript
// Multi-provider for collecting multiple values
export const PLUGINS = new InjectionToken<Plugin[]>('plugins');

// Providing multiple values
@NgModule({
  providers: [
    { provide: PLUGINS, useClass: Plugin1, multi: true },
    { provide: PLUGINS, useClass: Plugin2, multi: true },
    { provide: PLUGINS, useClass: Plugin3, multi: true }
  ]
})
export class AppModule { }

// Injecting all plugins
@Injectable()
export class PluginManager {
  constructor(@Inject(PLUGINS) private plugins: Plugin[]) {
    // plugins array contains instances of Plugin1, Plugin2, Plugin3
  }
}
```

---

## Advanced DI Concepts

### Optional Dependencies

```typescript
import { Injectable, Optional, Inject } from '@angular/core';

@Injectable()
export class ConfigService {
  constructor(
    @Optional() @Inject('OPTIONAL_CONFIG') private config?: any
  ) {
    if (this.config) {
      // Use config
    } else {
      // Use default behavior
    }
  }
}
```

### Factory Providers

```typescript
// Factory function
export function createLogger(config: AppConfig): Logger {
  return config.production ? new ProductionLogger() : new DevLogger();
}

// Provider configuration
@NgModule({
  providers: [
    {
      provide: Logger,
      useFactory: createLogger,
      deps: [APP_CONFIG]
    }
  ]
})
export class AppModule { }
```

### Self and SkipSelf Decorators

```typescript
@Injectable()
export class MyService {
  constructor(
    @Self() private selfService: SelfService, // Only from current injector
    @SkipSelf() private parentService: ParentService // Skip current injector
  ) { }
}
```

### Host Decorator

```typescript
@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
  constructor(
    @Host() private component: any // Only from host element
  ) { }
}
```

---

## HTTP and APIs

### Angular HttpClient Overview

Angular's HttpClient is built on top of RxJS and provides a powerful, type-safe way to communicate with backend services.

**Key Features:**
- **Type Safety**: Generic methods for typed responses
- **Interceptors**: Request/response transformation
- **Request/Response Objects**: Full access to HTTP details
- **Error Handling**: Built-in error handling with RxJS
- **Testing**: Built-in testing utilities

### Setting Up HttpClient

```typescript
// app.module.ts
import { HttpClientModule } from '@angular/common/http';

@NgModule({
  imports: [
    HttpClientModule
  ]
})
export class AppModule { }
```

---

## HTTP Methods

### GET Requests

```typescript
// Basic GET
getUsers(): Observable<User[]> {
  return this.http.get<User[]>('/api/users');
}

// GET with query parameters
getUsersWithParams(page: number, limit: number): Observable<User[]> {
  const params = new HttpParams()
    .set('page', page.toString())
    .set('limit', limit.toString());
  
  return this.http.get<User[]>('/api/users', { params });
}

// GET with full response
getUsersWithResponse(): Observable<HttpResponse<User[]>> {
  return this.http.get<User[]>('/api/users', { observe: 'response' });
}
```

### POST Requests

```typescript
// Basic POST
createUser(user: CreateUserDto): Observable<User> {
  return this.http.post<User>('/api/users', user);
}

// POST with custom headers
createUserWithHeaders(user: CreateUserDto): Observable<User> {
  const headers = new HttpHeaders({
    'Content-Type': 'application/json',
    'X-Custom-Header': 'custom-value'
  });

  return this.http.post<User>('/api/users', user, { headers });
}
```

### PUT Requests

```typescript
// Full update
updateUser(id: number, user: UpdateUserDto): Observable<User> {
  return this.http.put<User>(`/api/users/${id}`, user);
}

// Partial update with PATCH
patchUser(id: number, changes: Partial<User>): Observable<User> {
  return this.http.patch<User>(`/api/users/${id}`, changes);
}
```

### DELETE Requests

```typescript
// Basic DELETE
deleteUser(id: number): Observable<void> {
  return this.http.delete<void>(`/api/users/${id}`);
}

// DELETE with response body
deleteUserWithResponse(id: number): Observable<{ message: string }> {
  return this.http.delete<{ message: string }>(`/api/users/${id}`);
}
```

---

## Request Headers and Response Types

### Working with Headers

```typescript
// Setting headers
const headers = new HttpHeaders({
  'Authorization': 'Bearer token',
  'Content-Type': 'application/json',
  'Accept': 'application/json'
});

// Adding headers conditionally
let headers = new HttpHeaders();
if (token) {
  headers = headers.set('Authorization', `Bearer ${token}`);
}

// Appending headers
headers = headers.append('X-Custom', 'value');
```

### Response Types

```typescript
// JSON response (default)
getUsers(): Observable<User[]> {
  return this.http.get<User[]>('/api/users');
}

// Text response
getTextData(): Observable<string> {
  return this.http.get('/api/data', { responseType: 'text' });
}

// Blob response (for file downloads)
downloadFile(): Observable<Blob> {
  return this.http.get('/api/download', { responseType: 'blob' });
}

// ArrayBuffer response
getBinaryData(): Observable<ArrayBuffer> {
  return this.http.get('/api/binary', { responseType: 'arraybuffer' });
}

// Full HTTP response
getFullResponse(): Observable<HttpResponse<User[]>> {
  return this.http.get<User[]>('/api/users', { observe: 'response' });
}
```

### Request Options

```typescript
const options = {
  headers: new HttpHeaders({
    'Authorization': 'Bearer token'
  }),
  params: new HttpParams()
    .set('page', '1')
    .set('limit', '10'),
  responseType: 'json' as const,
  observe: 'response' as const,
  reportProgress: true
};

return this.http.get<User[]>('/api/users', options);
```

---

## Error Handling for HTTP Requests

### Basic Error Handling

```typescript
import { catchError, retry } from 'rxjs/operators';
import { throwError } from 'rxjs';

getUsers(): Observable<User[]> {
  return this.http.get<User[]>('/api/users').pipe(
    retry(3), // Retry failed requests 3 times
    catchError(this.handleError)
  );
}

private handleError(error: HttpErrorResponse): Observable<never> {
  let errorMessage = 'An error occurred';
  
  if (error.error instanceof ErrorEvent) {
    // Client-side error
    errorMessage = `Client Error: ${error.error.message}`;
  } else {
    // Server-side error
    errorMessage = `Server Error: ${error.status} - ${error.message}`;
  }
  
  console.error(errorMessage);
  return throwError(() => new Error(errorMessage));
}
```

### Advanced Error Handling Service

```typescript
@Injectable({
  providedIn: 'root'
})
export class ErrorHandlingService {
  
  handleError(error: HttpErrorResponse): Observable<never> {
    let userMessage: string;
    
    switch (error.status) {
      case 0:
        userMessage = 'Network error. Please check your connection.';
        break;
      case 400:
        userMessage = 'Bad request. Please check your input.';
        break;
      case 401:
        userMessage = 'Unauthorized. Please log in again.';
        this.redirectToLogin();
        break;
      case 403:
        userMessage = 'Forbidden. You don\'t have permission.';
        break;
      case 404:
        userMessage = 'Resource not found.';
        break;
      case 500:
        userMessage = 'Server error. Please try again later.';
        break;
      default:
        userMessage = 'An unexpected error occurred.';
    }
    
    this.notificationService.showError(userMessage);
    this.logError(error);
    
    return throwError(() => new Error(userMessage));
  }
  
  private redirectToLogin(): void {
    // Redirect to login page
  }
  
  private logError(error: HttpErrorResponse): void {
    // Log error to external service
  }
}
```

---

## HTTP Interceptors

### Creating an Interceptor

```typescript
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable()
export class BaseInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    // Clone the request to add headers
    const modifiedReq = req.clone({
      setHeaders: {
        'Content-Type': 'application/json'
      }
    });
    
    return next.handle(modifiedReq);
  }
}
```

### Registering Interceptors

```typescript
// app.module.ts
import { HTTP_INTERCEPTORS } from '@angular/common/http';

@NgModule({
  providers: [
    {
      provide: HTTP_INTERCEPTORS,
      useClass: BaseInterceptor,
      multi: true
    }
  ]
})
export class AppModule { }
```

---

## Authentication Interceptors

### JWT Token Interceptor

```typescript
@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  constructor(private authService: AuthService) { }

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const token = this.authService.getToken();
    
    if (token) {
      const authReq = req.clone({
        setHeaders: {
          Authorization: `Bearer ${token}`
        }
      });
      return next.handle(authReq);
    }
    
    return next.handle(req);
  }
}
```

### Advanced Auth Interceptor with Token Refresh

```typescript
@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  private isRefreshing = false;
  private refreshTokenSubject: BehaviorSubject<any> = new BehaviorSubject<any>(null);

  constructor(
    private authService: AuthService,
    private router: Router
  ) { }

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const token = this.authService.getToken();
    
    if (token) {
      req = this.addTokenToRequest(req, token);
    }

    return next.handle(req).pipe(
      catchError(error => {
        if (error instanceof HttpErrorResponse && error.status === 401) {
          return this.handle401Error(req, next);
        }
        return throwError(() => error);
      })
    );
  }

  private addTokenToRequest(req: HttpRequest<any>, token: string): HttpRequest<any> {
    return req.clone({
      setHeaders: {
        Authorization: `Bearer ${token}`
      }
    });
  }

  private handle401Error(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    if (!this.isRefreshing) {
      this.isRefreshing = true;
      this.refreshTokenSubject.next(null);

      const refreshToken = this.authService.getRefreshToken();
      
      if (refreshToken) {
        return this.authService.refreshToken().pipe(
          switchMap((token) => {
            this.isRefreshing = false;
            this.refreshTokenSubject.next(token);
            return next.handle(this.addTokenToRequest(req, token));
          }),
          catchError((err) => {
            this.isRefreshing = false;
            this.authService.logout();
            this.router.navigate(['/login']);
            return throwError(() => err);
          })
        );
      }
    }

    return this.refreshTokenSubject.pipe(
      filter(token => token !== null),
      take(1),
      switchMap((token) => next.handle(this.addTokenToRequest(req, token)))
    );
  }
}
```

---

## Logging Interceptors

### Request/Response Logging

```typescript
@Injectable()
export class LoggingInterceptor implements HttpInterceptor {
  constructor(private logger: LoggerService) { }

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const started = Date.now();
    let ok: string;

    return next.handle(req).pipe(
      tap(
        event => {
          if (event instanceof HttpResponse) {
            ok = 'succeeded';
          }
        },
        error => ok = 'failed'
      ),
      finalize(() => {
        const elapsed = Date.now() - started;
        const msg = `${req.method} "${req.urlWithParams}" ${ok} in ${elapsed} ms.`;
        this.logger.log(msg);
      })
    );
  }
}
```

### Detailed Logging with Request/Response Body

```typescript
@Injectable()
export class DetailedLoggingInterceptor implements HttpInterceptor {
  constructor(private logger: LoggerService) { }

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    // Log request
    this.logRequest(req);

    return next.handle(req).pipe(
      tap(
        event => {
          if (event instanceof HttpResponse) {
            this.logResponse(event);
          }
        },
        error => this.logError(error)
      )
    );
  }

  private logRequest(req: HttpRequest<any>): void {
    const logData = {
      method: req.method,
      url: req.urlWithParams,
      headers: req.headers.keys().reduce((acc, key) => {
        acc[key] = req.headers.get(key);
        return acc;
      }, {} as any),
      body: req.body
    };
    
    this.logger.log('HTTP Request:', logData);
  }

  private logResponse(res: HttpResponse<any>): void {
    const logData = {
      status: res.status,
      statusText: res.statusText,
      url: res.url,
      headers: res.headers.keys().reduce((acc, key) => {
        acc[key] = res.headers.get(key);
        return acc;
      }, {} as any),
      body: res.body
    };
    
    this.logger.log('HTTP Response:', logData);
  }

  private logError(error: HttpErrorResponse): void {
    this.logger.error('HTTP Error:', {
      status: error.status,
      message: error.message,
      url: error.url,
      error: error.error
    });
  }
}
```

---

## Caching Interceptors

### Simple Cache Interceptor

```typescript
@Injectable()
export class CacheInterceptor implements HttpInterceptor {
  private cache = new Map<string, HttpResponse<any>>();

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    // Only cache GET requests
    if (req.method !== 'GET') {
      return next.handle(req);
    }

    const cachedResponse = this.cache.get(req.url);
    if (cachedResponse) {
      return of(cachedResponse);
    }

    return next.handle(req).pipe(
      tap(event => {
        if (event instanceof HttpResponse) {
          this.cache.set(req.url, event);
        }
      })
    );
  }
}
```

### Advanced Cache with TTL

```typescript
interface CacheEntry {
  response: HttpResponse<any>;
  timestamp: number;
  ttl: number;
}

@Injectable()
export class AdvancedCacheInterceptor implements HttpInterceptor {
  private cache = new Map<string, CacheEntry>();
  private readonly defaultTtl = 5 * 60 * 1000; // 5 minutes

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    if (req.method !== 'GET') {
      return next.handle(req);
    }

    const cacheTtl = this.getCacheTtl(req);
    if (cacheTtl === 0) {
      return next.handle(req);
    }

    const cachedEntry = this.cache.get(req.url);
    if (cachedEntry && this.isCacheValid(cachedEntry)) {
      return of(cachedEntry.response);
    }

    return next.handle(req).pipe(
      tap(event => {
        if (event instanceof HttpResponse) {
          this.cache.set(req.url, {
            response: event,
            timestamp: Date.now(),
            ttl: cacheTtl
          });
        }
      })
    );
  }

  private getCacheTtl(req: HttpRequest<any>): number {
    const cacheControl = req.headers.get('Cache-Control');
    if (cacheControl?.includes('no-cache')) {
      return 0;
    }
    
    const customTtl = req.headers.get('X-Cache-TTL');
    return customTtl ? parseInt(customTtl, 10) : this.defaultTtl;
  }

  private isCacheValid(entry: CacheEntry): boolean {
    return Date.now() - entry.timestamp < entry.ttl;
  }

  clearCache(): void {
    this.cache.clear();
  }

  removeCacheEntry(url: string): void {
    this.cache.delete(url);
  }
}
```

---

## Best Practices

### Service Design Best Practices

1. **Single Responsibility**: Each service should have one clear purpose
2. **Immutability**: Use immutable data patterns with RxJS
3. **Error Handling**: Always handle errors appropriately
4. **Memory Management**: Unsubscribe from observables to prevent memory leaks
5. **Type Safety**: Use TypeScript interfaces for API responses

### DI Best Practices

1. **Use `providedIn: 'root'` for singleton services**
2. **Avoid circular dependencies**
3. **Use injection tokens for primitive values**
4. **Prefer constructor injection over property injection**
5. **Use factory providers for complex initialization**

### HTTP Best Practices

1. **Use interceptors for cross-cutting concerns**
2. **Implement proper error handling**
3. **Use typed HTTP responses**
4. **Cache GET requests when appropriate**
5. **Implement request/response logging for debugging**

---

## Common Patterns

### Repository Pattern

```typescript
// base-repository.ts
export abstract class BaseRepository<T> {
  protected abstract baseUrl: string;

  constructor(protected http: HttpClient) { }

  getAll(): Observable<T[]> {
    return this.http.get<T[]>(this.baseUrl);
  }

  getById(id: number): Observable<T> {
    return this.http.get<T>(`${this.baseUrl}/${id}`);
  }

  create(entity: Partial<T>): Observable<T> {
    return this.http.post<T>(this.baseUrl, entity);
  }

  update(id: number, entity: Partial<T>): Observable<T> {
    return this.http.put<T>(`${this.baseUrl}/${id}`, entity);
  }

  delete(id: number): Observable<void> {
    return this.http.delete<void>(`${this.baseUrl}/${id}`);
  }
}

// user-repository.ts
@Injectable({
  providedIn: 'root'
})
export class UserRepository extends BaseRepository<User> {
  protected baseUrl = '/api/users';

  constructor(http: HttpClient) {
    super(http);
  }

  getUsersByRole(role: string): Observable<User[]> {
    return this.http.get<User[]>(`${this.baseUrl}/by-role/${role}`);
  }
}
```

### State Management Pattern

```typescript
@Injectable({
  providedIn: 'root'
})
export class UserStateService {
  private readonly _users = new BehaviorSubject<User[]>([]);
  private readonly _loading = new BehaviorSubject<boolean>(false);
  private readonly _error = new BehaviorSubject<string | null>(null);

  public readonly users$ = this._users.asObservable();
  public readonly loading$ = this._loading.asObservable();
  public readonly error$ = this._error.asObservable();

  constructor(private userRepository: UserRepository) { }

  loadUsers(): void {
    this._loading.next(true);
    this._error.next(null);

    this.userRepository.getAll().pipe(
      finalize(() => this._loading.next(false))
    ).subscribe({
      next: (users) => this._users.next(users),
      error: (error) => this._error.next(error.message)
    });
  }

  addUser(user: Partial<User>): void {
    this._loading.next(true);
    
    this.userRepository.create(user).pipe(
      finalize(() => this._loading.next(false))
    ).subscribe({
      next: (newUser) => {
        const currentUsers = this._users.value;
        this._users.next([...currentUsers, newUser]);
      },
      error: (error) => this._error.next(error.message)
    });
  }

  updateUser(id: number, changes: Partial<User>): void {
    this._loading.next(true);
    
    this.userRepository.update(id, changes).pipe(
      finalize(() => this._loading.next(false))
    ).subscribe({
      next: (updatedUser) => {
        const currentUsers = this._users.value;
        const index = currentUsers.findIndex(u => u.id === id);
        if (index !== -1) {
          const newUsers = [...currentUsers];
          newUsers[index] = updatedUser;
          this._users.next(newUsers);
        }
      },
      error: (error) => this._error.next(error.message)
    });
  }

  deleteUser(id: number): void {
    this._loading.next(true);
    
    this.userRepository.delete(id).pipe(
      finalize(() => this._loading.next(false))
    ).subscribe({
      next: () => {
        const currentUsers = this._users.value;
        this._users.next(currentUsers.filter(u => u.id !== id));
      },
      error: (error) => this._error.next(error.message)
    });
  }
}
```

### Service Facade Pattern

```typescript
@Injectable({
  providedIn: 'root'
})
export class UserFacadeService {
  constructor(
    private userStateService: UserStateService,
    private userRepository: UserRepository,
    private notificationService: NotificationService,
    private validationService: ValidationService
  ) { }

  // Expose state observables
  users$ = this.userStateService.users$;
  loading$ = this.userStateService.loading$;
  error$ = this.userStateService.error$;

  // High-level operations
  async createUser(userData: CreateUserDto): Promise<void> {
    try {
      // Validate data
      const isValid = await this.validationService.validateUser(userData);
      if (!isValid) {
        throw new Error('Invalid user data');
      }

      // Create user
      this.userStateService.addUser(userData);
      
      // Show success notification
      this.notificationService.showSuccess('User created successfully');
    } catch (error) {
      this.notificationService.showError('Failed to create user');
      throw error;
    }
  }

  async updateUser(id: number, changes: Partial<User>): Promise<void> {
    try {
      // Validate changes
      const isValid = await this.validationService.validateUserChanges(changes);
      if (!isValid) {
        throw new Error('Invalid user changes');
      }

      this.userStateService.updateUser(id, changes);
      this.notificationService.showSuccess('User updated successfully');
    } catch (error) {
      this.notificationService.showError('Failed to update user');
      throw error;
    }
  }

  async deleteUser(id: number): Promise<void> {
    try {
      const confirmed = await this.notificationService.confirm('Are you sure you want to delete this user?');
      if (!confirmed) return;

      this.userStateService.deleteUser(id);
      this.notificationService.showSuccess('User deleted successfully');
    } catch (error) {
      this.notificationService.showError('Failed to delete user');
      throw error;
    }
  }

  loadUsers(): void {
    this.userStateService.loadUsers();
  }
}
```

### Generic HTTP Service Pattern

```typescript
@Injectable({
  providedIn: 'root'
})
export class ApiService {
  private baseUrl = environment.apiUrl;

  constructor(private http: HttpClient) { }

  get<T>(endpoint: string, params?: HttpParams): Observable<T> {
    return this.http.get<T>(`${this.baseUrl}${endpoint}`, { params }).pipe(
      this.handleResponse<T>()
    );
  }

  post<T>(endpoint: string, data: any): Observable<T> {
    return this.http.post<T>(`${this.baseUrl}${endpoint}`, data).pipe(
      this.handleResponse<T>()
    );
  }

  put<T>(endpoint: string, data: any): Observable<T> {
    return this.http.put<T>(`${this.baseUrl}${endpoint}`, data).pipe(
      this.handleResponse<T>()
    );
  }

  delete<T>(endpoint: string): Observable<T> {
    return this.http.delete<T>(`${this.baseUrl}${endpoint}`).pipe(
      this.handleResponse<T>()
    );
  }

  private handleResponse<T>(): OperatorFunction<T, T> {
    return pipe(
      retry(2),
      catchError(this.handleError)
    );
  }

  private handleError(error: HttpErrorResponse): Observable<never> {
    // Handle different error types
    if (error.error instanceof ErrorEvent) {
      console.error('Client Error:', error.error.message);
    } else {
      console.error('Server Error:', error.status, error.message);
    }
    
    return throwError(() => new Error('Something went wrong'));
  }
}
```

### Pagination Service Pattern

```typescript
interface PaginationParams {
  page: number;
  limit: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

interface PaginatedResponse<T> {
  data: T[];
  totalCount: number;
  page: number;
  limit: number;
  totalPages: number;
}

@Injectable({
  providedIn: 'root'
})
export class PaginationService<T> {
  private readonly _data = new BehaviorSubject<T[]>([]);
  private readonly _loading = new BehaviorSubject<boolean>(false);
  private readonly _pagination = new BehaviorSubject<PaginationParams>({
    page: 1,
    limit: 10
  });
  private readonly _totalCount = new BehaviorSubject<number>(0);

  public readonly data$ = this._data.asObservable();
  public readonly loading$ = this._loading.asObservable();
  public readonly pagination$ = this._pagination.asObservable();
  public readonly totalCount$ = this._totalCount.asObservable();

  public readonly totalPages$ = combineLatest([
    this.totalCount$,
    this.pagination$
  ]).pipe(
    map(([totalCount, pagination]) => 
      Math.ceil(totalCount / pagination.limit)
    )
  );

  constructor(private apiService: ApiService) { }

  loadData(endpoint: string, params?: PaginationParams): void {
    if (params) {
      this._pagination.next(params);
    }

    this._loading.next(true);
    
    const currentParams = this._pagination.value;
    const httpParams = new HttpParams()
      .set('page', currentParams.page.toString())
      .set('limit', currentParams.limit.toString());

    if (currentParams.sortBy) {
      httpParams.set('sortBy', currentParams.sortBy);
      httpParams.set('sortOrder', currentParams.sortOrder || 'asc');
    }

    this.apiService.get<PaginatedResponse<T>>(endpoint, httpParams).pipe(
      finalize(() => this._loading.next(false))
    ).subscribe({
      next: (response) => {
        this._data.next(response.data);
        this._totalCount.next(response.totalCount);
      },
      error: (error) => {
        console.error('Failed to load data:', error);
        this._data.next([]);
      }
    });
  }

  nextPage(): void {
    const current = this._pagination.value;
    this._pagination.next({ ...current, page: current.page + 1 });
  }

  previousPage(): void {
    const current = this._pagination.value;
    if (current.page > 1) {
      this._pagination.next({ ...current, page: current.page - 1 });
    }
  }

  goToPage(page: number): void {
    const current = this._pagination.value;
    this._pagination.next({ ...current, page });
  }

  changePageSize(limit: number): void {
    const current = this._pagination.value;
    this._pagination.next({ ...current, limit, page: 1 });
  }

  sortBy(field: string, order: 'asc' | 'desc' = 'asc'): void {
    const current = this._pagination.value;
    this._pagination.next({ 
      ...current, 
      sortBy: field, 
      sortOrder: order, 
      page: 1 
    });
  }
}
```

### Search Service Pattern

```typescript
@Injectable({
  providedIn: 'root'
})
export class SearchService<T> {
  private readonly _searchTerm = new BehaviorSubject<string>('');
  private readonly _results = new BehaviorSubject<T[]>([]);
  private readonly _loading = new BehaviorSubject<boolean>(false);
  private readonly _totalResults = new BehaviorSubject<number>(0);

  public readonly searchTerm$ = this._searchTerm.asObservable();
  public readonly results$ = this._results.asObservable();
  public readonly loading$ = this._loading.asObservable();
  public readonly totalResults$ = this._totalResults.asObservable();

  constructor(private apiService: ApiService) {
    // Debounce search term changes
    this.searchTerm$.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      filter(term => term.length >= 2 || term.length === 0)
    ).subscribe(term => {
      if (term.length === 0) {
        this._results.next([]);
        this._totalResults.next(0);
      } else {
        this.performSearch(term);
      }
    });
  }

  search(term: string): void {
    this._searchTerm.next(term);
  }

  private performSearch(term: string): void {
    this._loading.next(true);
    
    const params = new HttpParams().set('q', term);
    
    this.apiService.get<{ results: T[], totalCount: number }>('/search', params).pipe(
      finalize(() => this._loading.next(false))
    ).subscribe({
      next: (response) => {
        this._results.next(response.results);
        this._totalResults.next(response.totalCount);
      },
      error: (error) => {
        console.error('Search failed:', error);
        this._results.next([]);
        this._totalResults.next(0);
      }
    });
  }

  clearSearch(): void {
    this._searchTerm.next('');
  }
}
```

### File Upload Service Pattern

```typescript
@Injectable({
  providedIn: 'root'
})
export class FileUploadService {
  constructor(private http: HttpClient) { }

  uploadFile(file: File, endpoint: string): Observable<any> {
    const formData = new FormData();
    formData.append('file', file);

    return this.http.post(endpoint, formData, {
      reportProgress: true,
      observe: 'events'
    }).pipe(
      map(event => {
        switch (event.type) {
          case HttpEventType.UploadProgress:
            const progress = Math.round(100 * event.loaded / (event.total || 1));
            return { status: 'progress', progress };
          case HttpEventType.Response:
            return { status: 'complete', body: event.body };
          default:
            return { status: 'uploading' };
        }
      })
    );
  }

  uploadMultipleFiles(files: File[], endpoint: string): Observable<any> {
    const formData = new FormData();
    files.forEach((file, index) => {
      formData.append(`files[${index}]`, file);
    });

    return this.http.post(endpoint, formData, {
      reportProgress: true,
      observe: 'events'
    });
  }

  downloadFile(url: string, filename: string): Observable<Blob> {
    return this.http.get(url, { responseType: 'blob' }).pipe(
      tap(blob => {
        const downloadLink = document.createElement('a');
        const url = window.URL.createObjectURL(blob);
        downloadLink.href = url;
        downloadLink.download = filename;
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
        window.URL.revokeObjectURL(url);
      })
    );
  }
}
```

### WebSocket Service Pattern

```typescript
@Injectable({
  providedIn: 'root'
})
export class WebSocketService {
  private socket$ = new Subject<any>();
  private connection$ = new Subject<boolean>();
  private websocket?: WebSocket;

  public messages$ = this.socket$.asObservable();
  public isConnected$ = this.connection$.asObservable();

  connect(url: string): void {
    if (this.websocket) {
      this.websocket.close();
    }

    this.websocket = new WebSocket(url);

    this.websocket.onopen = () => {
      this.connection$.next(true);
    };

    this.websocket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      this.socket$.next(data);
    };

    this.websocket.onclose = () => {
      this.connection$.next(false);
    };

    this.websocket.onerror = (error) => {
      console.error('WebSocket error:', error);
      this.connection$.next(false);
    };
  }

  send(data: any): void {
    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
      this.websocket.send(JSON.stringify(data));
    }
  }

  disconnect(): void {
    if (this.websocket) {
      this.websocket.close();
      this.websocket = undefined;
    }
  }
}
```

### Configuration Service Pattern

```typescript
interface AppConfig {
  apiUrl: string;
  production: boolean;
  version: string;
  features: {
    enableNotifications: boolean;
    enableAnalytics: boolean;
    maxUploadSize: number;
  };
}

@Injectable({
  providedIn: 'root'
})
export class ConfigService {
  private config: AppConfig | null = null;

  constructor(private http: HttpClient) { }

  loadConfig(): Promise<AppConfig> {
    return this.http.get<AppConfig>('/assets/config.json').pipe(
      tap(config => this.config = config),
      catchError(() => {
        // Return default config if loading fails
        const defaultConfig: AppConfig = {
          apiUrl: 'https://api.example.com',
          production: false,
          version: '1.0.0',
          features: {
            enableNotifications: true,
            enableAnalytics: false,
            maxUploadSize: 10485760 // 10MB
          }
        };
        this.config = defaultConfig;
        return of(defaultConfig);
      })
    ).toPromise();
  }

  getConfig(): AppConfig {
    if (!this.config) {
      throw new Error('Configuration not loaded');
    }
    return this.config;
  }

  get apiUrl(): string {
    return this.getConfig().apiUrl;
  }

  get isProduction(): boolean {
    return this.getConfig().production;
  }

  get version(): string {
    return this.getConfig().version;
  }

  isFeatureEnabled(feature: keyof AppConfig['features']): boolean {
    return this.getConfig().features[feature] as boolean;
  }
}

// App initialization
export function initializeApp(configService: ConfigService): () => Promise<any> {
  return () => configService.loadConfig();
}

// In app.module.ts
@NgModule({
  providers: [
    {
      provide: APP_INITIALIZER,
      useFactory: initializeApp,
      deps: [ConfigService],
      multi: true
    }
  ]
})
export class AppModule { }
```

### Notification Service Pattern

```typescript
interface Notification {
  id: string;
  type: 'success' | 'error' | 'warning' | 'info';
  message: string;
  duration?: number;
  actions?: NotificationAction[];
}

interface NotificationAction {
  label: string;
  action: () => void;
}

@Injectable({
  providedIn: 'root'
})
export class NotificationService {
  private readonly _notifications = new BehaviorSubject<Notification[]>([]);
  public readonly notifications$ = this._notifications.asObservable();

  show(notification: Omit<Notification, 'id'>): string {
    const id = this.generateId();
    const newNotification: Notification = {
      id,
      ...notification
    };

    const current = this._notifications.value;
    this._notifications.next([...current, newNotification]);

    // Auto-remove after duration
    if (notification.duration !== 0) {
      setTimeout(() => {
        this.remove(id);
      }, notification.duration || 5000);
    }

    return id;
  }

  showSuccess(message: string, duration?: number): string {
    return this.show({ type: 'success', message, duration });
  }

  showError(message: string, duration?: number): string {
    return this.show({ type: 'error', message, duration });
  }

  showWarning(message: string, duration?: number): string {
    return this.show({ type: 'warning', message, duration });
  }

  showInfo(message: string, duration?: number): string {
    return this.show({ type: 'info', message, duration });
  }

  remove(id: string): void {
    const current = this._notifications.value;
    this._notifications.next(current.filter(n => n.id !== id));
  }

  clear(): void {
    this._notifications.next([]);
  }

  confirm(message: string): Promise<boolean> {
    return new Promise((resolve) => {
      const id = this.show({
        type: 'warning',
        message,
        duration: 0,
        actions: [
          {
            label: 'Cancel',
            action: () => {
              this.remove(id);
              resolve(false);
            }
          },
          {
            label: 'Confirm',
            action: () => {
              this.remove(id);
              resolve(true);
            }
          }
        ]
      });
    });
  }

  private generateId(): string {
    return Math.random().toString(36).substr(2, 9);
  }
}
```

### Performance Monitoring Service

```typescript
@Injectable({
  providedIn: 'root'
})
export class PerformanceMonitoringService {
  private performanceEntries: PerformanceEntry[] = [];

  constructor() {
    this.setupPerformanceObserver();
  }

  private setupPerformanceObserver(): void {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        this.performanceEntries.push(...list.getEntries());
        this.analyzePerformance();
      });

      observer.observe({ entryTypes: ['navigation', 'resource', 'measure'] });
    }
  }

  measureHttpRequest(url: string): (response: HttpResponse<any>) => HttpResponse<any> {
    const startTime = performance.now();
    
    return (response: HttpResponse<any>) => {
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      this.logHttpPerformance(url, duration, response.status);
      
      return response;
    };
  }

  private logHttpPerformance(url: string, duration: number, status: number): void {
    const entry = {
      type: 'http-request',
      url,
      duration,
      status,
      timestamp: Date.now()
    };

    // Log to console or send to analytics service
    console.log('HTTP Performance:', entry);
    
    // Alert for slow requests
    if (duration > 2000) {
      console.warn(`Slow HTTP request detected: ${url} took ${duration}ms`);
    }
  }

  private analyzePerformance(): void {
    const recentEntries = this.performanceEntries.slice(-10);
    const avgDuration = recentEntries.reduce((sum, entry) => sum + entry.duration, 0) / recentEntries.length;
    
    if (avgDuration > 1000) {
      console.warn('Performance degradation detected');
    }
  }

  getPerformanceReport(): any {
    return {
      entries: this.performanceEntries,
      summary: {
        totalRequests: this.performanceEntries.length,
        averageDuration: this.performanceEntries.reduce((sum, entry) => sum + entry.duration, 0) / this.performanceEntries.length,
        slowRequests: this.performanceEntries.filter(entry => entry.duration > 2000).length
      }
    };
  }
}
```

---

## Advanced Testing Patterns

### Testing Services with Dependencies

```typescript
// user.service.spec.ts
describe('UserService', () => {
  let service: UserService;
  let httpMock: HttpTestingController;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [UserService]
    });
    
    service = TestBed.inject(UserService);
    httpMock = TestBed.inject(HttpTestingController);
  });

  afterEach(() => {
    httpMock.verify();
  });

  it('should fetch users', () => {
    const mockUsers: User[] = [
      { id: 1, name: 'John', email: 'john@example.com' },
      { id: 2, name: 'Jane', email: 'jane@example.com' }
    ];

    service.getUsers().subscribe(users => {
      expect(users).toEqual(mockUsers);
    });

    const req = httpMock.expectOne('/api/users');
    expect(req.request.method).toBe('GET');
    req.flush(mockUsers);
  });

  it('should handle error when fetching users', () => {
    service.getUsers().subscribe({
      next: () => fail('Should have failed'),
      error: (error) => {
        expect(error.message).toContain('Server Error');
      }
    });

    const req = httpMock.expectOne('/api/users');
    req.flush('Server Error', { status: 500, statusText: 'Internal Server Error' });
  });
});
```

### Testing Interceptors

```typescript
// auth.interceptor.spec.ts
describe('AuthInterceptor', () => {
  let interceptor: AuthInterceptor;
  let authService: jasmine.SpyObj<AuthService>;

  beforeEach(() => {
    const spy = jasmine.createSpyObj('AuthService', ['getToken']);

    TestBed.configureTestingModule({
      providers: [
        AuthInterceptor,
        { provide: AuthService, useValue: spy }
      ]
    });

    interceptor = TestBed.inject(AuthInterceptor);
    authService = TestBed.inject(AuthService) as jasmine.SpyObj<AuthService>;
  });

  it('should add auth header when token exists', () => {
    const token = 'test-token';
    authService.getToken.and.returnValue(token);

    const req = new HttpRequest('GET', '/api/test');
    const next = jasmine.createSpy('next').and.returnValue(of(new HttpResponse()));

    interceptor.intercept(req, { handle: next }).subscribe();

    expect(next).toHaveBeenCalledWith(
      jasmine.objectContaining({
        headers: jasmine.objectContaining({
          Authorization: `Bearer ${token}`
        })
      })
    );
  });
});
```

This comprehensive guide covers all the essential aspects of Angular 13 Services, Dependency Injection, and HTTP client functionality. The examples provided are production-ready and follow Angular best practices. You can use these patterns as building blocks for your Angular applications, adapting them to your specific requirements.
# Angular Core Building Blocks and Templates Documentation

## Table of Contents

| # | Topic |
|---|-------|
| **Core Building Blocks** | |
| 1 | [Property Binding](#property-binding) |
| 2 | [Event Binding](#event-binding) |
| 3 | [Two-Way Data Binding](#two-way-data-binding) |
| 4 | [Class and Style Binding](#class-and-style-binding) |
| 5 | [Structural Directives](#structural-directives) |
| 6 | [Attribute Directives](#attribute-directives) |
| 7 | [Custom Directives](#custom-directives) |
| 8 | [Built-in Pipes](#built-in-pipes) |
| 9 | [Custom Pipes](#custom-pipes) |

## Property Binding

Property binding in Angular allows you to set properties of target elements or directives. It's a one-way data flow from a component's data property to a target element property.

### Key Features

* One-way binding from component to DOM
* Uses square brackets `[property]="expression"` syntax
* Updates when component property changes
* Can bind to standard HTML properties, custom properties, and directive inputs

### Examples

**Basic Property Binding**

```typescript
// component.ts
@Component({
  selector: 'app-property-binding',
  templateUrl: './property-binding.component.html'
})
export class PropertyBindingComponent {
  imageUrl = 'https://angular.io/assets/images/logos/angular/angular.png';
  isDisabled = true;
  buttonText = 'Click Me';
}
```

```html
<!-- property-binding.component.html -->
<!-- Binding to the src property of an image -->
<img [src]="imageUrl" alt="Angular Logo">

<!-- Binding to the disabled property of a button -->
<button [disabled]="isDisabled">{{ buttonText }}</button>

<!-- The following are equivalent -->
<button [disabled]="isDisabled">Button</button>
<button bind-disabled="isDisabled">Button</button>
```

**Property Binding to Custom Components**

```typescript
// parent.component.ts
@Component({
  selector: 'app-parent',
  template: `
    <app-child [message]="parentMessage"></app-child>
    <button (click)="updateMessage()">Update Message</button>
  `
})
export class ParentComponent {
  parentMessage = 'Message from parent';
  
  updateMessage() {
    this.parentMessage = 'Updated message from parent';
  }
}

// child.component.ts
@Component({
  selector: 'app-child',
  template: `<p>{{ message }}</p>`
})
export class ChildComponent {
  @Input() message: string = '';
}
```

### Best Practices

* Use property binding instead of string interpolation when setting element properties
* Be aware that property names are case-sensitive
* Remember that property binding works with properties, not attributes (HTML attributes initialize DOM properties)
* Avoid complex expressions in templates - move logic to the component


[Back to Top](#table-of-contents)

## Event Binding

Event binding allows you to listen for and respond to user actions such as keystrokes, mouse movements, clicks, and touches.

### Key Features

* One-way data flow from the view to the component
* Uses parentheses `(event)="handler()"` syntax
* Connects DOM events to component methods
* Can pass event data to the component method

### Examples

**Basic Event Binding**

```typescript
// component.ts
@Component({
  selector: 'app-event-binding',
  templateUrl: './event-binding.component.html'
})
export class EventBindingComponent {
  clickCount = 0;
  
  incrementCount() {
    this.clickCount++;
    console.log(`Button clicked ${this.clickCount} times`);
  }
  
  onKeyUp(event: KeyboardEvent) {
    console.log('Key pressed:', event.key);
  }
}
```

```html
<!-- event-binding.component.html -->
<button (click)="incrementCount()">Click me</button>
<p>Button clicked: {{ clickCount }} times</p>

<input (keyup)="onKeyUp($event)" placeholder="Type something">

<!-- Alternative syntax -->
<button on-click="incrementCount()">Click me (alternative syntax)</button>
```

**Output** (After clicking the button twice):
```
Button clicked 2 times
```

**Custom Event Binding with EventEmitter**

```typescript
// child.component.ts
@Component({
  selector: 'app-child',
  template: `
    <button (click)="sendMessageToParent()">Send Message to Parent</button>
  `
})
export class ChildComponent {
  @Output() messageEvent = new EventEmitter<string>();
  
  sendMessageToParent() {
    this.messageEvent.emit('Hello from child!');
  }
}

// parent.component.ts
@Component({
  selector: 'app-parent',
  template: `
    <app-child (messageEvent)="receiveMessage($event)"></app-child>
    <p>{{ message }}</p>
  `
})
export class ParentComponent {
  message = '';
  
  receiveMessage(msg: string) {
    this.message = msg;
  }
}
```

### Event Filtering

```typescript
@Component({
  selector: 'app-key-filter',
  template: `
    <input (keyup.enter)="onEnterPressed($event)" placeholder="Press Enter">
  `
})
export class KeyFilterComponent {
  onEnterPressed(event: KeyboardEvent) {
    console.log('Enter pressed, input value:', (event.target as HTMLInputElement).value);
  }
}
```

### Best Practices

* Keep event handlers simple or call methods that contain complex logic
* Use the `$event` object to access event data when needed
* Consider event filtering for keyboard, mouse, and other events
* Clean up event listeners in `ngOnDestroy` if using direct DOM event listeners

[Back to Top](#table-of-contents)

## Two-Way Data Binding

Two-way data binding combines property binding and event binding. It enables a two-way flow of data between the template and component, making it easy to synchronize values.

### Key Features

* Combines property binding and event binding
* Uses banana-in-a-box syntax `[(ngModel)]="property"`
* Automatically updates both the model and the view
* Requires the FormsModule to be imported for ngModel

### Examples

**Basic Two-Way Binding with ngModel**

```typescript
// app.module.ts
import { FormsModule } from '@angular/forms';

@NgModule({
  imports: [
    BrowserModule,
    FormsModule // Required for ngModel
  ],
  // other configurations
})
export class AppModule { }

// component.ts
@Component({
  selector: 'app-two-way',
  templateUrl: './two-way.component.html'
})
export class TwoWayComponent {
  name = 'John Doe';
  
  updateName() {
    this.name = 'Jane Smith';
  }
}
```

```html
<!-- two-way.component.html -->
<input [(ngModel)]="name" placeholder="Enter name">
<p>Current name: {{ name }}</p>
<button (click)="updateName()">Update Name</button>
```

**Under the Hood - How Two-Way Binding Works**

```html
<!-- The following are equivalent -->
<input [(ngModel)]="name">

<!-- This is what [(ngModel)] expands to -->
<input [ngModel]="name" (ngModelChange)="name = $event">
```

**Custom Two-Way Binding**

```typescript
// counter.component.ts
@Component({
  selector: 'app-counter',
  template: `
    <div>
      <button (click)="decrement()">-</button>
      <span>{{ value }}</span>
      <button (click)="increment()">+</button>
    </div>
  `
})
export class CounterComponent {
  @Input() value: number = 0;
  @Output() valueChange = new EventEmitter<number>();
  
  increment() {
    this.value++;
    this.valueChange.emit(this.value);
  }
  
  decrement() {
    this.value--;
    this.valueChange.emit(this.value);
  }
}

// parent.component.ts
@Component({
  selector: 'app-parent',
  template: `
    <app-counter [(value)]="counterValue"></app-counter>
    <p>Counter value: {{ counterValue }}</p>
  `
})
export class ParentComponent {
  counterValue = 5;
}
```

### Best Practices

* Import FormsModule in your application module to use ngModel
* Use two-way binding sparingly for simpler forms and component interactions
* For complex forms, consider using Reactive Forms instead
* Follow naming convention of `[property]` and `(propertyChange)` for custom two-way binding

[Back to Top](#table-of-contents)

## Class and Style Binding

Class and style binding allows you to dynamically add or remove CSS classes and inline styles based on component state.

### Key Features

* Dynamically manipulate CSS classes and styles
* Class binding uses `[class]` or `[class.className]` syntax
* Style binding uses `[style]` or `[style.styleName]` syntax
* Supports adding/removing multiple classes and styles at once

### Examples

**Class Binding**

```typescript
// component.ts
@Component({
  selector: 'app-class-binding',
  templateUrl: './class-binding.component.html',
  styles: [`
    .text-success { color: green; }
    .text-danger { color: red; }
    .text-large { font-size: 24px; }
    .bold { font-weight: bold; }
  `]
})
export class ClassBindingComponent {
  isSpecial = true;
  canSave = false;
  status = 'error';
  
  // Object for [class] binding
  classObject = {
    'text-success': false,
    'text-danger': true,
    'text-large': true,
    'bold': true
  };
  
  toggleSpecial() {
    this.isSpecial = !this.isSpecial;
  }
}
```

```html
<!-- class-binding.component.html -->
<!-- Single class binding -->
<div [class.text-success]="isSpecial">Text with conditional class binding</div>

<!-- Multiple classes using ngClass with an object -->
<div [ngClass]="{'text-success': isSpecial, 'bold': isSpecial, 'text-large': !isSpecial}">
  Multiple class binding with object
</div>

<!-- Multiple classes using ngClass with a method -->
<div [ngClass]="getClasses()">Multiple class binding with method</div>

<!-- Multiple classes using [class] with object -->
<div [class]="classObject">Multiple class binding with class object</div>

<!-- Multiple classes using [class] with string -->
<div [class]="isSpecial ? 'text-success bold' : 'text-danger'">Class binding with string</div>
```

```typescript
// Additional method for the component
getClasses() {
  return {
    'text-success': this.status === 'success',
    'text-danger': this.status === 'error',
    'bold': this.canSave
  };
}
```

**Style Binding**

```typescript
// component.ts
@Component({
  selector: 'app-style-binding',
  templateUrl: './style-binding.component.html'
})
export class StyleBindingComponent {
  isBold = true;
  fontSize = 16;
  textColor = 'blue';
  
  // Object for [style] binding
  styleObject = {
    'color': 'purple',
    'font-weight': 'bold',
    'font-size.px': 20
  };
  
  toggleWeight() {
    this.isBold = !this.isBold;
  }
}
```

```html
<!-- style-binding.component.html -->
<!-- Single style binding -->
<div [style.font-weight]="isBold ? 'bold' : 'normal'">Text with conditional style binding</div>

<!-- Style binding with units -->
<div [style.font-size.px]="fontSize">Text with style binding and units</div>

<!-- Multiple styles using ngStyle -->
<div [ngStyle]="{'color': textColor, 'font-weight': isBold ? 'bold' : 'normal'}">
  Multiple style binding with ngStyle
</div>

<!-- Multiple styles using [style] with object -->
<div [style]="styleObject">Multiple style binding with style object</div>
```

### Comparison: Class vs Style Binding

| Feature | Class Binding | Style Binding |
|---------|---------------|---------------|
| **Basic Syntax** | `[class.className]="expression"` | `[style.styleName]="expression"` |
| **Multiple Values** | `[class]="{class1: expr1, class2: expr2}"` | `[style]="{style1: expr1, style2: expr2}"` |
| **Directive Form** | `[ngClass]="classExpression"` | `[ngStyle]="styleExpression"` |
| **Use Case** | When working with predefined CSS classes | For dynamic inline styles |
| **Performance** | Better for grouped styling changes | Use when styles need to be calculated |
| **Units** | N/A | Supports unit extensions (px, em, %, etc.) |

### Best Practices

* Use class binding over style binding when possible
* Prefer component CSS and class binding for most styling needs
* Use style binding for dynamic styles that depend on component state
* Avoid complex expressions in templates - compute styles/classes in component code
* Consider using `[ngClass]` and `[ngStyle]` for complex scenarios with multiple classes/styles

[Back to Top](#table-of-contents)

## Structural Directives

Structural directives modify the DOM layout by adding, removing, or manipulating elements. They are denoted by an asterisk (*) prefix.

### Key Features

* Change the structure of the DOM layout
* Use asterisk (*) prefix syntax as shorthand for `<ng-template>`
* Core structural directives: *ngIf, *ngFor, *ngSwitch
* Can't have multiple structural directives on the same element

### Examples

**ngIf - Conditional Rendering**

```typescript
// component.ts
@Component({
  selector: 'app-ngif-example',
  templateUrl: './ngif-example.component.html'
})
export class NgIfExampleComponent {
  showContent = true;
  isLoggedIn = false;
  userRole = 'admin';
  
  toggleContent() {
    this.showContent = !this.showContent;
  }
  
  login() {
    this.isLoggedIn = true;
  }
  
  logout() {
    this.isLoggedIn = false;
  }
}
```

```html
<!-- ngif-example.component.html -->
<!-- Basic ngIf -->
<div *ngIf="showContent">Content is visible when showContent is true</div>
<button (click)="toggleContent()">Toggle Content</button>

<!-- ngIf with else template -->
<div *ngIf="isLoggedIn; else loginTemplate">
  Welcome User! You are logged in.
  <button (click)="logout()">Logout</button>
</div>
<ng-template #loginTemplate>
  <button (click)="login()">Login</button>
</ng-template>

<!-- ngIf with then and else templates -->
<div *ngIf="isLoggedIn; then loggedInTemplate else loggedOutTemplate"></div>

<ng-template #loggedInTemplate>
  <p>User is authenticated</p>
  <div *ngIf="userRole === 'admin'">
    <p>Admin dashboard</p>
  </div>
</ng-template>

<ng-template #loggedOutTemplate>
  <p>Please log in to access the application</p>
</ng-template>
```

**ngFor - List Rendering**

```typescript
// component.ts
@Component({
  selector: 'app-ngfor-example',
  templateUrl: './ngfor-example.component.html'
})
export class NgForExampleComponent {
  users = [
    { id: 1, name: 'Alice', role: 'Admin' },
    { id: 2, name: 'Bob', role: 'User' },
    { id: 3, name: 'Charlie', role: 'User' },
    { id: 4, name: 'David', role: 'Manager' }
  ];
  
  addUser() {
    this.users.push({ id: this.users.length + 1, name: 'New User', role: 'User' });
  }
  
  trackById(index: number, user: any) {
    return user.id;
  }
}
```

```html
<!-- ngfor-example.component.html -->
<!-- Basic ngFor -->
<ul>
  <li *ngFor="let user of users">{{ user.name }} - {{ user.role }}</li>
</ul>

<!-- ngFor with index -->
<ul>
  <li *ngFor="let user of users; let i = index">
    {{ i + 1 }}. {{ user.name }} - {{ user.role }}
  </li>
</ul>

<!-- ngFor with multiple exported values -->
<ul>
  <li *ngFor="let user of users; 
              let i = index; 
              let first = first; 
              let last = last; 
              let even = even; 
              let odd = odd;
              trackBy: trackById">
    <span [class.text-primary]="first" [class.text-danger]="last">
      {{ i + 1 }}. {{ user.name }} - {{ user.role }}
    </span>
    <span *ngIf="even">(Even)</span>
    <span *ngIf="odd">(Odd)</span>
  </li>
</ul>

<button (click)="addUser()">Add User</button>
```

**ngSwitch - Switch Case Rendering**

```typescript
// component.ts
@Component({
  selector: 'app-ngswitch-example',
  templateUrl: './ngswitch-example.component.html'
})
export class NgSwitchExampleComponent {
  currentTab = 'home';
  userType = 'admin';
  
  switchTab(tab: string) {
    this.currentTab = tab;
  }
}
```

```html
<!-- ngswitch-example.component.html -->
<!-- Tab switching example -->
<div>
  <button (click)="switchTab('home')">Home</button>
  <button (click)="switchTab('profile')">Profile</button>
  <button (click)="switchTab('messages')">Messages</button>
  <button (click)="switchTab('settings')">Settings</button>
</div>

<div [ngSwitch]="currentTab">
  <div *ngSwitchCase="'home'">Home Content</div>
  <div *ngSwitchCase="'profile'">Profile Content</div>
  <div *ngSwitchCase="'messages'">Messages Content</div>
  <div *ngSwitchCase="'settings'">Settings Content</div>
  <div *ngSwitchDefault>Select a tab</div>
</div>

<!-- User type example -->
<div [ngSwitch]="userType">
  <div *ngSwitchCase="'admin'">
    <h3>Admin Dashboard</h3>
    <p>Full system access</p>
  </div>
  <div *ngSwitchCase="'manager'">
    <h3>Manager Dashboard</h3>
    <p>Department-level access</p>
  </div>
  <div *ngSwitchCase="'user'">
    <h3>User Dashboard</h3>
    <p>Regular user access</p>
  </div>
  <div *ngSwitchDefault>
    <h3>Guest Dashboard</h3>
    <p>Limited access</p>
  </div>
</div>
```

### Understanding Structural Directive Syntax

The asterisk (*) syntax is shorthand for `<ng-template>`. Here's how the transformation works:

```html
<!-- This -->
<div *ngIf="showContent">Content</div>

<!-- Is equivalent to this -->
<ng-template [ngIf]="showContent">
  <div>Content</div>
</ng-template>

<!-- Similarly, for ngFor -->
<div *ngFor="let item of items">{{ item }}</div>

<!-- Is equivalent to -->
<ng-template ngFor let-item [ngForOf]="items">
  <div>{{ item }}</div>
</ng-template>
```

### Best Practices

* Use `ngIf` with `else` for conditional rendering
* Implement `trackBy` with `ngFor` to improve performance with large lists
* Avoid putting multiple structural directives on a single element
* Use `ng-container` when you need multiple structural directives (see next section)
* Consider extracting complex conditional logic into component methods

[Back to Top](#table-of-contents)

## Attribute Directives

Attribute directives change the appearance or behavior of an element, component, or another directive. They are applied as attributes to elements.

### Key Features

* Do not change DOM structure, only modify elements they are attached to
* Key built-in directives: ngClass, ngStyle
* Can be applied simultaneously with other attribute directives
* Can take inputs to customize behavior

### Examples

**ngClass Directive**

```typescript
// component.ts
@Component({
  selector: 'app-ngclass-example',
  templateUrl: './ngclass-example.component.html',
  styles: [`
    .success { color: green; background-color: lightgreen; padding: 10px; }
    .warning { color: orange; background-color: lightyellow; padding: 10px; }
    .error { color: red; background-color: lightpink; padding: 10px; }
    .bold { font-weight: bold; }
    .italic { font-style: italic; }
  `]
})
export class NgClassExampleComponent {
  isSuccess = true;
  isWarning = false;
  isError = false;
  isBold = true;
  isItalic = false;
  
  messageType = 'success';
  
  // Method for ngClass
  setClasses() {
    return {
      success: this.isSuccess,
      warning: this.isWarning,
      error: this.isError,
      bold: this.isBold,
      italic: this.isItalic
    };
  }
  
  toggleSuccess() { this.isSuccess = !this.isSuccess; }
  toggleWarning() { this.isWarning = !this.isWarning; }
  toggleError() { this.isError = !this.isError; }
  toggleBold() { this.isBold = !this.isBold; }
  toggleItalic() { this.isItalic = !this.isItalic; }
}
```

```html
<!-- ngclass-example.component.html -->
<!-- String syntax -->
<div [ngClass]="'bold italic'">String syntax with hardcoded classes</div>

<!-- Array syntax -->
<div [ngClass]="['bold', 'italic']">Array syntax with hardcoded classes</div>

<!-- Object syntax -->
<div [ngClass]="{'bold': isBold, 'italic': isItalic}">
  Object syntax with conditional classes
</div>

<!-- Method syntax -->
<div [ngClass]="setClasses()">Method syntax for dynamic classes</div>

<!-- Dynamic message type example -->
<div [ngClass]="{
  'success': messageType === 'success',
  'warning': messageType === 'warning',
  'error': messageType === 'error'
}">
  Message with type: {{ messageType }}
</div>

<!-- Controls -->
<div>
  <button (click)="toggleBold()">Toggle Bold</button>
  <button (click)="toggleItalic()">Toggle Italic</button>
  <button (click)="messageType = 'success'">Success</button>
  <button (click)="messageType = 'warning'">Warning</button>
  <button (click)="messageType = 'error'">Error</button>
</div>
```

**ngStyle Directive**

```typescript
// component.ts
@Component({
  selector: 'app-ngstyle-example',
  templateUrl: './ngstyle-example.component.html'
})
export class NgStyleExampleComponent {
  color = 'blue';
  fontSize = 16;
  isBold = true;
  
  // Method for ngStyle
  setStyles() {
    return {
      'color': this.color,
      'font-size.px': this.fontSize,
      'font-weight': this.isBold ? 'bold' : 'normal'
    };
  }
  
  incrementFontSize() { this.fontSize += 2; }
  decrementFontSize() { this.fontSize -= 2; }
  toggleBold() { this.isBold = !this.isBold; }
  
  colorOptions = ['blue', 'red', 'green', 'purple', 'orange'];
  
  changeColor(newColor: string) {
    this.color = newColor;
  }
}
```

```html
<!-- ngstyle-example.component.html -->
<!-- Object syntax -->
<div [ngStyle]="{'color': color, 'font-size.px': fontSize, 'font-weight': isBold ? 'bold' : 'normal'}">
  Text styled with ngStyle object
</div>

<!-- Method syntax -->
<div [ngStyle]="setStyles()">Text styled with ngStyle method</div>

<!-- Controls -->
<div>
  <button (click)="incrementFontSize()">Increase Font</button>
  <button (click)="decrementFontSize()">Decrease Font</button>
  <button (click)="toggleBold()">Toggle Bold</button>
  
  <div>
    <p>Select color:</p>
    <button *ngFor="let colorOption of colorOptions" 
            (click)="changeColor(colorOption)"
            [style.background-color]="colorOption"
            style="margin: 2px; padding: 5px;">
      {{ colorOption }}
    </button>
  </div>
</div>
```

### Comparison: ngClass vs ngStyle

| Feature | ngClass | ngStyle |
|---------|---------|---------|
| **Purpose** | Add/remove CSS classes | Set inline styles |
| **Performance** | Better for grouped styling | Better for individual style changes |
| **Object Syntax** | `[ngClass]="{'class': expr}"` | `[ngStyle]="{'style': value}"` |
| **Array Syntax** | `[ngClass]="['class1', 'class2']"` | Not available |
| **String Syntax** | `[ngClass]="'class1 class2'"` | Not available |
| **Units** | N/A | Supports unit extensions (.px, .em, etc.) |
| **Best For** | Predefined styles in CSS | Dynamic calculated styles |

### Best Practices

* Use `ngClass` when working with predefined CSS classes
* Use `ngStyle` for truly dynamic styles that need calculation
* Extract complex style/class logic to component methods
* Remember that standard class and style bindings can be used for simpler cases
* Avoid deeply nested conditional style logic in templates

[Back to Top](#table-of-contents)

## Custom Directives

Custom directives allow you to create reusable behaviors that can be applied to elements in your templates.

### Key Features

* Extend Angular's template capabilities
* Three types: Component, Structural, and Attribute directives
* Created using `@Directive` decorator
* Can respond to user events, take inputs, and modify elements

### Examples

**Basic Attribute Directive**

```typescript
// highlight.directive.ts
import { Directive, ElementRef, HostListener, Input } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
  @Input() appHighlight = '';
  @Input() defaultColor = 'yellow';
  
  constructor(private el: ElementRef) {}
  
  @HostListener('mouseenter') onMouseEnter() {
    this.highlight(this.appHighlight || this.defaultColor);
  }
  
  @HostListener('mouseleave') onMouseLeave() {
    this.highlight('');
  }
  
  private highlight(color: string) {
    this.el.nativeElement.style.backgroundColor = color;
  }
}

// app.module.ts
@NgModule({
  declarations: [
    AppComponent,
    HighlightDirective
  ],
  // other configuration
})
export class AppModule { }
```

```html
<!-- component.html -->
<p appHighlight="lightblue">Hover over me to see highlighting</p>
<p appHighlight defaultColor="lightgreen">Hover over me with default color</p>
```

**Advanced Attribute Directive with HostBinding**

```typescript
// tooltip.directive.ts
import { Directive, Input, ElementRef, HostListener, HostBinding, Renderer2 } from '@angular/core';

@Directive({
  selector: '[appTooltip]'
})
export class TooltipDirective {
  @Input('appTooltip') tooltipText = '';
  @Input() tooltipPosition = 'top';
  
  @HostBinding('class.tooltip-host') isTooltipHost = true;
  
  private tooltipElement: HTMLElement | null = null;
  
  constructor(private el: ElementRef, private renderer: Renderer2) {}
  
  @HostListener('mouseenter') onMouseEnter() {
    this.showTooltip();
  }
  
  @HostListener('mouseleave') onMouseLeave() {
    this.hideTooltip();
  }
  
  private showTooltip() {
    // Create tooltip element
    this.tooltipElement = this.renderer.createElement('div');
    const text = this.renderer.createText(this.tooltipText);
    
    this.renderer.appendChild(this.tooltipElement, text);
    this.renderer.addClass(this.tooltipElement, 'tooltip');
    this.renderer.addClass(this.tooltipElement, `tooltip-${this.tooltipPosition}`);
    
    // Add to DOM
    this.renderer.appendChild(document.body, this.tooltipElement);
    
    // Position the tooltip
    const hostPos = this.el.nativeElement.getBoundingClientRect();
    const tooltipPos = this.tooltipElement.getBoundingClientRect();
    
    let top, left;
    
    switch(this.tooltipPosition) {
      case 'top':
        top = hostPos.top - tooltipPos.height - 10;
        left = hostPos.left + (hostPos.width - tooltipPos.width) / 2;
        break;
      case 'bottom':
        top = hostPos.bottom + 10;
        left = hostPos.left + (hostPos.width - tooltipPos.width) / 2;
        break;
      case 'left':
        top = hostPos.top + (hostPos.height - tooltipPos.height) / 2;
        left = hostPos.left - tooltipPos.width - 10;
        break;
      case 'right':
        top = hostPos.top + (hostPos.height - tooltipPos.height) / 2;
        left = hostPos.right + 10;
        break;
    }
    
    this.renderer.setStyle(this.tooltipElement, 'top', `${top}px`);
    this.renderer.setStyle(this.tooltipElement, 'left', `${left}px`);
  }
  
  private hideTooltip() {
    if (this.tooltipElement) {
      this.renderer.removeChild(document.body, this.tooltipElement);
      this.tooltipElement = null;
    }
  }
}

// CSS in global styles.css
/*
.tooltip {
  position: absolute;
  background-color: black;
  color: white;
  padding: 5px 10px;
  border-radius: 4px;
  z-index: 1000;
}

.tooltip-host {
  position: relative;
}
*/
```

```html
<!-- component.html -->
<button appTooltip="Click to save" tooltipPosition="top">Save</button>
<button appTooltip="Click to delete" tooltipPosition="bottom">Delete</button>
<span appTooltip="This is a help text">Help Icon</span>
```

**Custom Structural Directive**

```typescript
// unless.directive.ts
import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[appUnless]'
})
export class UnlessDirective {
  private hasView = false;

  constructor(
    private templateRef: TemplateRef<any>,
    private viewContainer: ViewContainerRef
  ) { }

  @Input() set appUnless(condition: boolean) {
    // If condition is falsy and view hasn't been created yet
    if (!condition && !this.hasView) {
      // Create the embedded view from the template
      this.viewContainer.createEmbeddedView(this.templateRef);
      this.hasView = true;
    } else if (condition && this.hasView) {
      // If condition is truthy and view exists, clear the view
      this.viewContainer.clear();
      this.hasView = false;
    }
  }
}

// app.module.ts
@NgModule({
  declarations: [
    AppComponent,
    UnlessDirective
  ],
  // other configuration
})
export class AppModule { }
```

```html
<!-- component.html -->
<div *appUnless="condition">
  This content will be shown when the condition is false
</div>

<!-- The following is what Angular transforms the above into -->
<ng-template [appUnless]="condition">
  <div>This content will be shown when the condition is false</div>
</ng-template>
```

```typescript
// component.ts
@Component({
  selector: 'app-structural-directive-example',
  templateUrl: './structural-directive-example.component.html'
})
export class StructuralDirectiveExampleComponent {
  condition = false;
  
  toggleCondition() {
    this.condition = !this.condition;
  }
}
```

### Best Practices

* Follow naming conventions: prefix directive selectors to avoid conflicts
* Use ElementRef carefully and prefer Renderer2 for DOM manipulation
* Implement OnDestroy to clean up event listeners or subscriptions
* Consider using HostListener and HostBinding for cleaner code
* Document the API of your directives, especially inputs and outputs
* Test directives thoroughly, including edge cases
* Consider using NG_VALUE_ACCESSOR to create custom form controls

[Back to Top](#table-of-contents)

## Built-in Pipes

Pipes in Angular are simple functions that transform input values to display output in the template. Angular provides several built-in pipes for common transformations.

### Key Features

* Transform data in templates without changing the original value
* Can be chained using the pipe operator (`|`)
* Can accept parameters after the colon (`:`)
* Built-in pipes are provided by Angular's CommonModule
* Are pure by default (only recalculate when input changes)

### Examples

**String Pipes**

```typescript
// component.ts
@Component({
  selector: 'app-string-pipes',
  templateUrl: './string-pipes.component.html'
})
export class StringPipesComponent {
  title = 'angular pipe examples';
  message = 'Learn Angular Pipes';
  longText = 'This is a very long text that will be truncated using the slice pipe.';
  json = { name: 'John', age: 30, city: 'New York' };
}
```

```html
<!-- string-pipes.component.html -->
<h2>String Pipes</h2>

<!-- uppercase pipe -->
<p>{{ title | uppercase }}</p>
<!-- Output: ANGULAR PIPE EXAMPLES -->

<!-- lowercase pipe -->
<p>{{ message | lowercase }}</p>
<!-- Output: learn angular pipes -->

<!-- titlecase pipe -->
<p>{{ title | titlecase }}</p>
<!-- Output: Angular Pipe Examples -->

<!-- slice pipe -->
<p>{{ longText | slice:0:20 }}...</p>
<!-- Output: This is a very long t... -->

<!-- json pipe -->
<pre>{{ json | json }}</pre>
<!-- Output:
{
  "name": "John",
  "age": 30,
  "city": "New York"
}
-->
```

**Number and Math Pipes**

```typescript
// component.ts
@Component({
  selector: 'app-number-pipes',
  templateUrl: './number-pipes.component.html'
})
export class NumberPipesComponent {
  pi = 3.14159265359;
  e = 2.71828;
  amount = 1234.56;
  percentage = 0.8675;
  largeNumber = 1234567890;
}
```

```html
<!-- number-pipes.component.html -->
<h2>Number Pipes</h2>

<!-- number pipe with various formats -->
<p>Default: {{ pi | number }}</p>
<!-- Output: 3.142 -->

<p>With digits info: {{ pi | number:'1.2-5' }}</p>
<!-- Output: 3.14159 (at least 2 decimals, at most 5) -->

<p>Fixed number of digits: {{ e | number:'1.4-4' }}</p>
<!-- Output: 2.7183 -->

<!-- currency pipe -->
<p>Default currency: {{ amount | currency }}</p>
<!-- Output: $1,234.56 -->

<p>EUR: {{ amount | currency:'EUR' }}</p>
<!-- Output: €1,234.56 -->

<p>JPY with symbol: {{ amount | currency:'JPY':'symbol':'1.0-0' }}</p>
<!-- Output: ¥1,235 -->

<!-- percent pipe -->
<p>Default percent: {{ percentage | percent }}</p>
<!-- Output: 87% -->

<p>Percent with 2 decimals: {{ percentage | percent:'1.2-2' }}</p>
<!-- Output: 86.75% -->

<!-- Using decimal pipe for custom number formatting -->
<p>Decimal pipe: {{ largeNumber | number }}</p>
<!-- Output: 1,234,567,890 -->
```

**Date Pipe**

```typescript
// component.ts
@Component({
  selector: 'app-date-pipes',
  templateUrl: './date-pipes.component.html'
})
export class DatePipesComponent {
  currentDate = new Date();
  birthday = new Date(1990, 0, 15); // January 15, 1990
}
```

```html
<!-- date-pipes.component.html -->
<h2>Date Pipes</h2>

<!-- Date pipe with various formats -->
<p>Default date: {{ currentDate | date }}</p>
<!-- Output: May 1, 2025 -->

<p>Short date: {{ currentDate | date:'shortDate' }}</p>
<!-- Output: 5/1/25 -->

<p>Full date: {{ currentDate | date:'fullDate' }}</p>
<!-- Output: Thursday, May 1, 2025 -->

<p>Custom format: {{ currentDate | date:'MM/dd/yyyy' }}</p>
<!-- Output: 05/01/2025 -->

<p>With time: {{ currentDate | date:'medium' }}</p>
<!-- Output: May 1, 2025, 12:00:00 PM -->

<p>Short time: {{ currentDate | date:'shortTime' }}</p>
<!-- Output: 12:00 PM -->

<p>Day and month name: {{ birthday | date:'EEEE, MMMM d' }}</p>
<!-- Output: Monday, January 15 -->
```

**Other Built-in Pipes**

```typescript
// component.ts
@Component({
  selector: 'app-other-pipes',
  templateUrl: './other-pipes.component.html'
})
export class OtherPipesComponent {
  asyncData = new Promise<string>(resolve => {
    setTimeout(() => resolve('Async data loaded!'), 2000);
  });
  
  observable$ = interval(1000).pipe(
    take(5),
    map(v => `Observable value: ${v}`)
  );
  
  items = ['apple', 'banana', 'cherry', 'date'];
  selectedItem = null;
  
  nullValue = null;
  emptyString = '';
  zero = 0;
}
```

```html
<!-- other-pipes.component.html -->
<h2>Other Built-in Pipes</h2>

<!-- async pipe with Promise -->
<p>Async Promise: {{ asyncData | async }}</p>
<!-- Output after 2 seconds: Async data loaded! -->

<!-- async pipe with Observable -->
<p>Async Observable: {{ observable$ | async }}</p>
<!-- Output updates every second: Observable value: 0, 1, 2, etc. -->

<!-- i18nSelect pipe -->
<p>{{ selectedItem | i18nSelect: {
    'apple': 'You selected an apple',
    'banana': 'You selected a banana',
    'cherry': 'You selected a cherry',
    'date': 'You selected a date',
    'other': 'Please select an item'
  } }}
</p>

<!-- i18nPlural pipe -->
<p>{{ items.length | i18nPlural: {
    '=0': 'No items',
    '=1': 'One item',
    'other': '# items'
  } }}
</p>
<!-- Output: 4 items -->

<!-- KeyValue pipe -->
<div>
  <p>Object entries:</p>
  <ul>
    <li *ngFor="let entry of { name: 'John', age: 30 } | keyvalue">
      {{ entry.key }}: {{ entry.value }}
    </li>
  </ul>
</div>

<!-- nullish coalescing with the OR operator in expressions -->
<p>Null value: {{ nullValue || 'Default for null' }}</p>
<p>Empty string: {{ emptyString || 'Default for empty string' }}</p>
<p>Zero: {{ zero || 'Default for zero' }}</p>
```

### Pipe Chaining and Parameters

```html
<!-- Chaining multiple pipes -->
<p>{{ birthday | date:'fullDate' | uppercase }}</p>
<!-- Output: THURSDAY, MAY 1, 2025 -->

<!-- Pipe with parameters -->
<p>{{ pi | number:'1.5-5' }}</p>
<!-- Output: 3.14159 -->

<!-- Multiple parameters using colons -->
<p>{{ amount | currency:'GBP':'symbol':'1.2-2' }}</p>
<!-- Output: £1,234.56 -->
```

### Best Practices

* Use pipes for simple transformations in templates
* Chain pipes when needed, but avoid complex chains
* Consider pre-calculating values in the component for complex transformations
* Use the `async` pipe to handle observables and promises
* Be aware of pure vs. impure pipes and their performance implications
* Remember that pipes don't modify the original data
* For complex formatting requirements, consider creating a custom pipe

[Back to Top](#table-of-contents)

## Custom Pipes

Custom pipes allow you to create reusable transformations that are not covered by Angular's built-in pipes.

### Key Features

* Define transformations specific to your application
* Created using `@Pipe` decorator
* Must implement the `PipeTransform` interface
* Can be pure or impure (defaults to pure)
* Can accept multiple arguments

### Examples

**Basic Custom Pipe**

```typescript
// exponential-strength.pipe.ts
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'exponentialStrength'
})
export class ExponentialStrengthPipe implements PipeTransform {
  transform(value: number, exponent: number = 1): number {
    return Math.pow(value, exponent);
  }
}

// app.module.ts
@NgModule({
  declarations: [
    AppComponent,
    ExponentialStrengthPipe
  ],
  // other configuration
})
export class AppModule { }
```

```html
<!-- component.html -->
<p>2 raised to the power of 5 is: {{ 2 | exponentialStrength:5 }}</p>
<!-- Output: 2 raised to the power of 5 is: 32 -->

<p>Base {{ base }} raised to the power of {{ exponent }} is: 
   {{ base | exponentialStrength:exponent }}</p>
```

```typescript
// component.ts
@Component({
  selector: 'app-custom-pipe-example',
  templateUrl: './custom-pipe-example.component.html'
})
export class CustomPipeExampleComponent {
  base = 2;
  exponent = 10;
}
```

**Filter Pipe Example**

```typescript
// filter.pipe.ts
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'filter'
})
export class FilterPipe implements PipeTransform {
  transform(items: any[], searchText: string, field: string = ''): any[] {
    if (!items) return [];
    if (!searchText) return items;
    
    searchText = searchText.toLowerCase();
    
    return items.filter(item => {
      if (field) {
        // If a specific field is provided, search only in that field
        return item[field].toLowerCase().includes(searchText);
      } else {
        // Otherwise check if any property contains the search text
        return Object.keys(item).some(key => {
          return String(item[key]).toLowerCase().includes(searchText);
        });
      }
    });
  }
}
```

```html
<!-- component.html -->
<input type="text" [(ngModel)]="searchText" placeholder="Search...">

<ul>
  <li *ngFor="let user of users | filter:searchText:'name'">
    {{ user.name }} ({{ user.email }})
  </li>
</ul>
```

```typescript
// component.ts
@Component({
  selector: 'app-filter-pipe-example',
  templateUrl: './filter-pipe-example.component.html'
})
export class FilterPipeExampleComponent {
  searchText = '';
  users = [
    { id: 1, name: 'John Doe', email: 'john@example.com', role: 'Admin' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com', role: 'User' },
    { id: 3, name: 'Bob Johnson', email: 'bob@example.com', role: 'User' },
    { id: 4, name: 'Alice Brown', email: 'alice@example.com', role: 'Manager' }
  ];
}
```

**Impure Pipe Example**

```typescript
// countdown.pipe.ts
import { Pipe, PipeTransform, OnDestroy, ChangeDetectorRef } from '@angular/core';

@Pipe({
  name: 'countdown',
  pure: false // Impure pipe - will be triggered on each change detection cycle
})
export class CountdownPipe implements PipeTransform, OnDestroy {
  private timer: any;
  private lastValue: number = 0;
  private lastOutput: string = '';
  
  constructor(private changeDetectorRef: ChangeDetectorRef) {}
  
  transform(value: number): string {
    if (this.timer) {
      clearInterval(this.timer);
    }
    
    if (value !== this.lastValue) {
      this.lastValue = value;
      this.lastOutput = this.formatTime(value);
      
      if (value > 0) {
        let remainingTime = value;
        this.timer = setInterval(() => {
          remainingTime -= 1;
          if (remainingTime < 0) {
            clearInterval(this.timer);
          } else {
            this.lastOutput = this.formatTime(remainingTime);
            this.changeDetectorRef.markForCheck();
          }
        }, 1000);
      }
    }
    
    return this.lastOutput;
  }
  
  private formatTime(seconds: number): string {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
  }
  
  ngOnDestroy() {
    if (this.timer) {
      clearInterval(this.timer);
    }
  }
}
```

```html
<!-- component.html -->
<p>Countdown: {{ countdownTime | countdown }}</p>
<button (click)="resetCountdown()">Reset Countdown</button>
```

```typescript
// component.ts
@Component({
  selector: 'app-impure-pipe-example',
  templateUrl: './impure-pipe-example.component.html'
})
export class ImpurePipeExampleComponent {
  countdownTime = 60; // 60 seconds
  
  resetCountdown() {
    this.countdownTime = 60;
  }
}
```

### Pure vs Impure Pipes

| Feature | Pure Pipe | Impure Pipe |
|---------|-----------|-------------|
| **Default** | Yes | No |
| **Change Detection** | Only when input values change | On every change detection cycle |
| **Performance** | Better | May impact performance |
| **Use Case** | Simple transformations of input data | Dynamic calculations, values that change over time |
| **Implementation** | `@Pipe({ name: 'pipeName' })` | `@Pipe({ name: 'pipeName', pure: false })` |
| **Examples** | Most transformations like formatting | Filtering, sorting, real-time updates |

### Best Practices

* Prefer pure pipes for better performance
* Implement `OnDestroy` in impure pipes to clean up resources
* Keep pipe logic simple and focused on a single transformation
* Avoid complex data manipulation in pipes, especially in impure pipes
* Document the API of your pipes, especially their parameters
* Remember that pure pipes operate only on primitive input changes or object references
* Test pipes thoroughly, especially edge cases like null inputs
* Consider pre-calculating values in the component for complex transformations

[Back to Top](#table-of-contents)
